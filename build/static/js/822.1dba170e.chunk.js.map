{"version":3,"file":"static/js/822.1dba170e.chunk.js","mappings":"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AiC,IAAVA,EEgD5BmB,CAAYnB,EAAO,a,eCxElC,MAAMoB,EAA8B,CACzC,MACA,SACA,QACA,Y,eCNK,MAAMC,EAAS,CACpB,UACA,UACA,QACA,aACA,OACA,KACA,UACA,SACA,MACA,WACA,KACA,SACA,MACA,MACA,KACA,KACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,SACA,KACA,KACA,UACA,OACA,OACA,MACA,KACA,WACA,SACA,IACA,YACA,MACA,UACA,UACA,QACA,QACA,KACA,KACA,QACA,KACA,KACA,QACA,KACA,KACA,MACA,OC3DWC,EAAU,CAErB,SACA,QACA,SACA,YCLWC,EAAY,CACvB,OACA,OACA,WACA,SACA,WACA,OACA,OACA,OACA,UACA,WACA,QACA,KACA,SACA,SACA,QACA,WACA,QACA,SCoCIC,EAAe,GACfC,GAAgBC,EAAAA,EAAAA,GAAQ,CAAC,UAAW,YAmC1C,SAASC,EAAOjB,EAAMkB,GACpB,GAAI,aAAclB,EAAM,CACtB,MAAMmB,EAAW,IAAID,GASrB,OAPkB,SAAdlB,EAAK9B,MAAmBkD,EAAUpB,MACpCmB,EAASE,QAAS,EAClBF,EAASG,OAAQ,GAGnBH,EAASI,WAyPb,SAAyBvB,EAAMkB,GAC7B,GAAI,YAAalB,GAAQA,EAAKC,WAC5B,OAAQD,EAAKzB,SAGX,IAAK,UACL,IAAK,YACL,IAAK,SACL,IAAK,QACL,IAAK,MACH,MAAO,MAGT,IAAK,OACH,MAAO,SAGT,IAAK,MACH,OAAOyB,EAAKC,WAAWuB,KAAO,WAAa,MAG7C,IAAK,KACL,IAAK,KACH,OAAOxB,EAAKC,WAAWwB,OAAS,SAAWP,EAAMK,WAGnD,IAAK,WACH,MAAO,WAOb,OAAOL,EAAMK,WA3RWG,CAAgB1B,EAAMkB,GAiEhD,SAAaxD,EAAQwD,GACnB,IAAIG,EAASH,EAAMG,OACnB,MAAMC,EAAQJ,EAAMI,MACdnD,EAAWT,EAAOS,SACxB,IAAIQ,EAASR,EAASQ,OAClBlB,GAAS,EAEb,OAASA,EAAQkB,GAAQ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","sources":["../node_modules/hast-util-is-element/lib/index.js","../node_modules/hast-util-embedded/lib/index.js","../node_modules/hast-util-has-property/lib/index.js","../node_modules/hast-util-is-body-ok-link/lib/index.js","../node_modules/hast-util-phrasing/lib/index.js","../node_modules/html-whitespace-sensitive-tag-names/lib/index.js","../node_modules/rehype-minify-whitespace/lib/block.js","../node_modules/rehype-minify-whitespace/lib/content.js","../node_modules/rehype-minify-whitespace/lib/skippable.js","../node_modules/rehype-minify-whitespace/lib/index.js","../node_modules/rehype-format/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parents} Parents\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is an element.\n * @param {unknown} this\n *   Context object (`this`) to call `test` with\n * @param {unknown} [element]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | null | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n *\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary element.\n *\n *   * when `string`, checks that the element has that tag name\n *   * when `function`, see `TestFunction`\n *   * when `Array`, checks if one of the subtests pass\n *\n * @callback TestFunction\n *   Check if an element passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Element} element\n *   An element.\n * @param {number | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean | undefined | void}\n *   Whether this element passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `element` is an `Element` and whether it passes the given test.\n *\n * @param element\n *   Thing to check, typically `element`.\n * @param test\n *   Check for a specific element.\n * @param index\n *   Position of `element` in its parent.\n * @param parent\n *   Parent of `element`.\n * @param context\n *   Context object (`this`) to call `test` with.\n * @returns\n *   Whether `element` is an `Element` and passes a test.\n * @throws\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\n *   thrown when `element` is not a node or not an element.\n */\nexport const isElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((element?: null | undefined) => false) &\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [element]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parents | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (element, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== null &&\n        index !== undefined &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite `index`')\n      }\n\n      if (\n        parent !== null &&\n        parent !== undefined &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected valid `parent`')\n      }\n\n      if (\n        (index === null || index === undefined) !==\n        (parent === null || parent === undefined)\n      ) {\n        throw new Error('Expected both `index` and `parent`')\n      }\n\n      return looksLikeAnElement(element)\n        ? check.call(context, element, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate a check from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * an `element`, `index`, and `parent`.\n *\n * @param test\n *   A test for a specific element.\n * @returns\n *   A check.\n */\nexport const convertElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      // Assume array.\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as `test`')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction tagNameFactory(check) {\n  return castFactory(tagName)\n\n  /**\n   * @param {Element} element\n   * @returns {boolean}\n   */\n  function tagName(element) {\n    return element.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeAnElement(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} element\n * @returns {element is Element}\n */\nfunction element(element) {\n  return Boolean(\n    element &&\n      typeof element === 'object' &&\n      'type' in element &&\n      element.type === 'element' &&\n      'tagName' in element &&\n      typeof element.tagName === 'string'\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Element}\n */\nfunction looksLikeAnElement(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    'tagName' in value\n  )\n}\n","import {convertElement} from 'hast-util-is-element'\n\n/**\n * Check if a node is a *embedded content*.\n *\n * @param value\n *   Thing to check (typically `Node`).\n * @returns\n *   Whether `value` is an element considered embedded content.\n *\n *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,\n *   `object`, `picture`, `svg`, and `video` are embedded content.\n */\nexport const embedded = convertElement(\n  /**\n   * @param element\n   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}\n   */\n  function (element) {\n    return (\n      element.tagName === 'audio' ||\n      element.tagName === 'canvas' ||\n      element.tagName === 'embed' ||\n      element.tagName === 'iframe' ||\n      element.tagName === 'img' ||\n      element.tagName === 'math' ||\n      element.tagName === 'object' ||\n      element.tagName === 'picture' ||\n      element.tagName === 'svg' ||\n      element.tagName === 'video'\n    )\n  }\n)\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node` is an element and has a `name` property.\n *\n * @template {string} Key\n *   Type of key.\n * @param {Nodes} node\n *   Node to check (typically `Element`).\n * @param {Key} name\n *   Property name to check.\n * @returns {node is Element & {properties: Record<Key, Array<number | string> | number | string | true>}}}\n *   Whether `node` is an element that has a `name` property.\n *\n *   Note: see <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/27c9274/types/hast/index.d.ts#L37C29-L37C98>.\n */\nexport function hasProperty(node, name) {\n  const value =\n    node.type === 'element' &&\n    own.call(node.properties, name) &&\n    node.properties[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n","/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\nconst list = new Set(['pingback', 'prefetch', 'stylesheet'])\n\n/**\n * Checks whether a node is a “body OK” link.\n *\n * @param {Nodes} node\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is a “body OK” link.\n */\nexport function isBodyOkLink(node) {\n  if (node.type !== 'element' || node.tagName !== 'link') {\n    return false\n  }\n\n  if (node.properties.itemProp) {\n    return true\n  }\n\n  const rel = node.properties.rel\n  let index = -1\n\n  if (!Array.isArray(rel) || rel.length === 0) {\n    return false\n  }\n\n  while (++index < rel.length) {\n    if (!list.has(String(rel[index]))) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isBodyOkLink} from 'hast-util-is-body-ok-link'\nimport {convertElement} from 'hast-util-is-element'\n\nconst basic = convertElement([\n  'a',\n  'abbr',\n  // `area` is in fact only phrasing if it is inside a `map` element.\n  // However, since `area`s are required to be inside a `map` element, and it’s\n  // a rather involved check, it’s ignored here for now.\n  'area',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'i',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'output',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'wbr'\n])\n\nconst meta = convertElement('meta')\n\n/**\n * Check if the given value is *phrasing* content.\n *\n * @param {Nodes} value\n *   Node to check.\n * @returns {boolean}\n *   Whether `value` is phrasing content.\n */\nexport function phrasing(value) {\n  return Boolean(\n    value.type === 'text' ||\n      basic(value) ||\n      embedded(value) ||\n      isBodyOkLink(value) ||\n      (meta(value) && hasProperty(value, 'itemProp'))\n  )\n}\n","/**\n * List of HTML tag names that are whitespace sensitive.\n */\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n","// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nexport const blocks = [\n  'address', // Flow content.\n  'article', // Sections and headings.\n  'aside', // Sections and headings.\n  'blockquote', // Flow content.\n  'body', // Page.\n  'br', // Contribute whitespace intrinsically.\n  'caption', // Similar to block.\n  'center', // Flow content, legacy.\n  'col', // Similar to block.\n  'colgroup', // Similar to block.\n  'dd', // Lists.\n  'dialog', // Flow content.\n  'dir', // Lists, legacy.\n  'div', // Flow content.\n  'dl', // Lists.\n  'dt', // Lists.\n  'figcaption', // Flow content.\n  'figure', // Flow content.\n  'footer', // Flow content.\n  'form', // Flow content.\n  'h1', // Sections and headings.\n  'h2', // Sections and headings.\n  'h3', // Sections and headings.\n  'h4', // Sections and headings.\n  'h5', // Sections and headings.\n  'h6', // Sections and headings.\n  'head', // Page.\n  'header', // Flow content.\n  'hgroup', // Sections and headings.\n  'hr', // Flow content.\n  'html', // Page.\n  'legend', // Flow content.\n  'li', // Block-like.\n  'li', // Similar to block.\n  'listing', // Flow content, legacy\n  'main', // Flow content.\n  'menu', // Lists.\n  'nav', // Sections and headings.\n  'ol', // Lists.\n  'optgroup', // Similar to block.\n  'option', // Similar to block.\n  'p', // Flow content.\n  'plaintext', // Flow content, legacy\n  'pre', // Flow content.\n  'section', // Sections and headings.\n  'summary', // Similar to block.\n  'table', // Similar to block.\n  'tbody', // Similar to block.\n  'td', // Block-like.\n  'td', // Similar to block.\n  'tfoot', // Similar to block.\n  'th', // Block-like.\n  'th', // Similar to block.\n  'thead', // Similar to block.\n  'tr', // Similar to block.\n  'ul', // Lists.\n  'wbr', // Contribute whitespace intrinsically.\n  'xmp' // Flow content, legacy\n]\n","export const content = [\n  // Form.\n  'button',\n  'input',\n  'select',\n  'textarea'\n]\n","export const skippable = [\n  'area',\n  'base',\n  'basefont',\n  'dialog',\n  'datalist',\n  'head',\n  'link',\n  'meta',\n  'noembed',\n  'noframes',\n  'param',\n  'rp',\n  'script',\n  'source',\n  'style',\n  'template',\n  'track',\n  'title'\n]\n","/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @callback Collapse\n *   Collapse a string.\n * @param {string} value\n *   Value to collapse.\n * @returns {string}\n *   Collapsed value.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [newlines=false]\n *   Collapse whitespace containing newlines to `'\\n'` instead of `' '`\n *   (default: `false`); the default is to collapse to a single space.\n *\n * @typedef Result\n *   Result.\n * @property {boolean} remove\n *   Whether to remove.\n * @property {boolean} ignore\n *   Whether to ignore.\n * @property {boolean} stripAtStart\n *   Whether to strip at the start.\n *\n * @typedef State\n *   Info passed around.\n * @property {Collapse} collapse\n *   Collapse.\n * @property {Whitespace} whitespace\n *   Current whitespace.\n * @property {boolean | undefined} [before]\n *   Whether there is a break before (default: `false`).\n * @property {boolean | undefined} [after]\n *   Whether there is a break after (default: `false`).\n *\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Whitespace setting.\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespace} from 'hast-util-whitespace'\nimport {convert} from 'unist-util-is'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  const settings = options || emptyOptions\n  const collapse = collapseFactory(\n    settings.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minify(node, state) {\n  if ('children' in node) {\n    const settings = {...state}\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, state)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (state.whitespace === 'normal') {\n      return minifyText(node, state)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (state.whitespace === 'nowrap') {\n      node.value = state.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {ignore: ignorableNode(node), stripAtStart: false, remove: false}\n}\n\n/**\n * @param {Text} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minifyText(node, state) {\n  const value = state.collapse(node.value)\n  const result = {ignore: false, stripAtStart: false, remove: false}\n  let start = 0\n  let end = value.length\n\n  if (state.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (state.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Parents} parent\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction all(parent, state) {\n  let before = state.before\n  const after = state.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(children[index], {\n      ...state,\n      after: collapsableAfter(children, index, after),\n      before\n    })\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {ignore: false, stripAtStart: Boolean(before || after), remove: false}\n}\n\n/**\n * @param {Array<Nodes>} nodes\n *   Nodes.\n * @param {number} index\n *   Index.\n * @param {boolean | undefined} [after]\n *   Whether there is a break after `nodes` (default: `false`).\n * @returns {boolean | undefined}\n *   Whether there is a break after the node at `index`.\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean | undefined}\n *   Boundary.\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is block-like.\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Parents} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction skippable(node) {\n  return (\n    Boolean(node.type === 'element' && node.properties.hidden) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n *   Character.\n * @returns {boolean}\n *   Whether `character` is removable.\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {Collapse} replace\n * @returns {Collapse}\n *   Collapse.\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @type {Collapse}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Parents} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Whitespace}\n *   Whitespace.\n */\nfunction inferWhiteSpace(node, state) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return node.properties.noWrap ? 'nowrap' : state.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return state.whitespace\n}\n","/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Array<string> | null | undefined} [blanks=[]]\n *   List of tag names to join with a blank line (default: `[]`); these tags,\n *   when next to each other, are joined by a blank line (`\\n\\n`); for example,\n *   when `['head', 'body']` is given, a blank line is added between these two.\n * @property {number | string | null | undefined} [indent=2]\n *   Indentation per level (default: `2`); when number, uses that amount of\n *   spaces; when `string`, uses that per indentation level.\n * @property {boolean | null | undefined} [indentInitial=true]\n *   Whether to indent the first level (default: `true`); this is usually the\n *   `<html>`, thus not indenting `head` and `body`.\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {isElement} from 'hast-util-is-element'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst transformWhitespace = rehypeMinifyWhitespace({newlines: true})\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  const settings = options || emptyOptions\n  let indent = settings.indent || 2\n  let indentInitial = settings.indentInitial\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent)\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    /** @type {boolean | undefined} */\n    let head\n\n    transformWhitespace(tree)\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, function (node, parents) {\n      let index = -1\n\n      if (!('children' in node)) {\n        return\n      }\n\n      if (isElement(node, 'head')) {\n        head = true\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP\n      }\n\n      const children = node.children\n      let level = parents.length\n\n      // Don’t indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return\n      }\n\n      if (!indentInitial) {\n        level--\n      }\n\n      /** @type {boolean | undefined} */\n      let eol\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true\n          }\n\n          child.value = child.value.replace(\n            / *\\n/g,\n            '$&' + String(indent).repeat(level)\n          )\n        }\n      }\n\n      /** @type {Array<RootContent>} */\n      const result = []\n      /** @type {RootContent | undefined} */\n      let previous\n\n      index = -1\n\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (padding(child, head) || (eol && !index)) {\n          addBreak(result, level, child)\n          eol = true\n        }\n\n        previous = child\n        result.push(child)\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop()\n          previous = result[result.length - 1]\n        }\n\n        addBreak(result, level - 1)\n      }\n\n      node.children = result\n    })\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(previous) && blank(next) ? '\\n\\n' : '\\n') +\n      String(indent).repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n\n  /**\n   * @param {Nodes | undefined} node\n   *   Node.\n   * @returns {boolean}\n   *   Whether `node` is a blank.\n   */\n  function blank(node) {\n    return Boolean(\n      node &&\n        node.type === 'element' &&\n        settings.blanks &&\n        settings.blanks.length > 0 &&\n        settings.blanks.includes(node.tagName)\n    )\n  }\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {boolean | undefined} head\n *   Whether the node is in `head`.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(node, head) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? head || isElement(node, 'script') || embedded(node) || !phrasing(node)\n      : false)\n  )\n}\n"],"names":["isElement","element","test","index","parent","context","check","convertElement","undefined","Number","POSITIVE_INFINITY","Error","type","children","looksLikeAnElement","call","castFactory","tagName","tagNameFactory","tests","checks","length","any","_len","arguments","parameters","Array","_key","apply","this","anyFactory","testFunction","value","Boolean","embedded","own","hasOwnProperty","list","Set","basic","meta","phrasing","node","properties","itemProp","rel","isArray","has","String","isBodyOkLink","name","hasProperty","whitespaceSensitiveTagNames","blocks","content","skippable","emptyOptions","ignorableNode","convert","minify","state","settings","blocklike","before","after","whitespace","wrap","noWrap","inferWhiteSpace","result","collapsableAfter","remove","splice","ignore","stripAtStart","all","collapse","start","end","removable","charAt","slice","minifyText","nodes","inferBoundary","contents","hidden","skippables","character","replaceNewlines","match","exec","replaceWhitespace","transformWhitespace","options","replace","collapseFactory","newlines","tree","rehypeMinifyWhitespace","rehypeFormat","indent","indentInitial","repeat","head","visitParents","parents","SKIP","eol","level","padding","child","includes","previous","addBreak","push","pop","next","tail","blank","Math","max","blanks"],"sourceRoot":""}