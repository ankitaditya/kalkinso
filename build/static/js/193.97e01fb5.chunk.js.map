{"version":3,"file":"static/js/193.97e01fb5.chunk.js","mappings":"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","sources":["../node_modules/@blocknote/core/node_modules/mdast-util-to-string/lib/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/configure.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/@blocknote/core/node_modules/mdast-util-phrasing/lib/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/join.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/unsafe.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/index.js","../node_modules/@blocknote/core/node_modules/remark-stringify/lib/index.js","../node_modules/@blocknote/core/node_modules/unist-util-visit/lib/index.js","../node_modules/zwitch/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: we’ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: we’ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\n */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it’s value is this function’s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it’s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn’t have a `key` property, the special\n   * “invalid” handler will be called.\n   * If `value` has an unknown `key`, the special “unknown” handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it’s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it’s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n"],"names":["emptyOptions","toString","value","options","settings","one","includeImageAlt","includeHtml","Boolean","node","type","alt","all","children","Array","isArray","values","result","index","length","join","configure","base","extension","key","extensions","Object","assign","map","line","_","blank","hardBreak","_1","state","info","unsafe","character","patternInScope","stack","test","before","formatCodeAsIndented","fences","lang","checkQuote","marker","quote","Error","emphasis","checkEmphasis","exit","enter","tracker","createTracker","move","containerPhrasing","after","current","peek","formatHeadingAsSetext","literalWithBreak","visit","EXIT","depth","setext","html","image","suffix","subexit","safe","url","title","concat","imageReference","referenceType","reference","associationId","slice","formatLinkAsAutolink","raw","resourceLink","link","linkReference","text","checkBulletOrdered","bulletOrdered","checkRule","rule","phrasing","convert","strong","checkStrong","handle","blockquote","shift","indentLines","containerFlow","break","code","fence","checkFence","sequence","repeat","Math","max","longestStreak","encode","meta","definition","heading","rank","min","lastIndexOf","charCodeAt","toUpperCase","closeAtx","inlineCode","list","parent","bulletCurrent","bullet","ordered","checkBullet","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","bulletLastUsed","useDifferentMarker","firstListItem","undefined","indexStack","item","listItem","paragraph","root","some","d","call","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","left","right","spread","fullPhrasingSpans","inConstruct","notInConstruct","atBreak","invalid","unknown","joinDefinition","containerPhrasingBound","this","containerFlowBound","safeBound","config","remarkStringify","Compiler","tree","data","arguments","association","track","handlers","tightDefinitions","zwitch","now","column","lineShift","name","push","pop","toMarkdown","visitor","reverse","visitParents","parents","indexOf","own","hasOwnProperty","fn","id","String","_len","parameters","_key"],"sourceRoot":""}