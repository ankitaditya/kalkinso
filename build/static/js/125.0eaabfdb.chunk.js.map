{"version":3,"file":"static/js/125.0eaabfdb.chunk.js","mappings":"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","sources":["../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/@blocknote/core/node_modules/micromark-util-decode-numeric-character-reference/index.js","../node_modules/@blocknote/core/node_modules/micromark-util-decode-string/index.js","../node_modules/@blocknote/core/node_modules/unist-util-is/lib/index.js","../node_modules/@blocknote/core/node_modules/unist-util-visit-parents/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > 126 && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||\n    // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n"],"names":["inlineCode","node","_","state","value","sequence","index","RegExp","test","unsafe","length","pattern","expression","patternCompile","match","atBreak","exec","position","charCodeAt","slice","peek","listItem","parent","info","listItemIndent","style","options","Error","checkListItemIndent","bullet","bulletCurrent","checkBullet","type","ordered","start","incrementListMarker","children","indexOf","size","spread","Math","ceil","tracker","createTracker","move","repeat","shift","exit","enter","indentLines","containerFlow","current","line","blank","association","label","identifier","decodeString","marker","indexStack","results","push","child","handle","before","after","bulletLastUsed","undefined","between","pop","join","left","right","result","containerPhrasing","handlers","charAt","replace","eol","map","one","_compiled","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","safe","input","config","positions","infos","Boolean","sort","numerical","end","escapeBackslashes","encode","toString","toUpperCase","a","b","whole","track","now","lineShift","column","chunks","split","tail","decodeNumericCharacterReference","base","code","Number","parseInt","String","fromCharCode","characterEscapeOrReference","decode","$0","$1","$2","head","hex","decodeNamedCharacterReference","convert","ok","check","castFactory","typeFactory","Array","isArray","tests","checks","any","_len","arguments","parameters","_key","call","this","anyFactory","all","key","propsFactory","_len2","_key2","EXIT","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","Object","defineProperty","visit","subresult","offset","grandparents","toResult","concat"],"sourceRoot":""}