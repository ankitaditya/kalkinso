{"version":3,"file":"static/js/85.ccc8ebdd.chunk.js","mappings":"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","sources":["../node_modules/hast-util-to-mdast/lib/util/own.js","../node_modules/hast-util-to-mdast/lib/util/wrap-text.js","../node_modules/hast-util-to-mdast/lib/one.js","../node_modules/hast-util-to-mdast/lib/all.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-embedded/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-is-body-ok-link/index.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-phrasing/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/unist-util-is/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/mdast-util-phrasing/lib/index.js","../node_modules/hast-util-to-mdast/lib/util/wrap.js","../node_modules/hast-util-to-mdast/lib/util/wrap-children.js","../node_modules/hast-util-to-mdast/lib/util/resolve.js","../node_modules/hast-util-to-text/node_modules/hast-util-is-element/index.js","../node_modules/unist-util-find-after/node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-find-after/lib/index.js","../node_modules/hast-util-to-text/lib/index.js","../node_modules/hast-util-to-mdast/lib/handlers/code.js","../node_modules/trim-trailing-lines/index.js","../node_modules/hast-util-to-mdast/lib/handlers/del.js","../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js","../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../node_modules/hast-util-to-mdast/lib/handlers/em.js","../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../node_modules/hast-util-to-mdast/lib/handlers/img.js","../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../node_modules/hast-util-to-mdast/lib/handlers/input.js","../node_modules/hast-util-to-mdast/lib/handlers/li.js","../node_modules/hast-util-to-mdast/lib/handlers/list.js","../node_modules/hast-util-to-mdast/node_modules/mdast-util-to-string/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/hast-util-to-mdast/node_modules/unist-util-visit/lib/index.js","../node_modules/hast-util-to-mdast/lib/handlers/media.js","../node_modules/hast-util-to-mdast/lib/handlers/p.js","../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../node_modules/hast-util-to-mdast/lib/handlers/table.js","../node_modules/hast-util-to-mdast/lib/handlers/index.js","../node_modules/hast-util-to-mdast/lib/handlers/root.js","../node_modules/hast-util-to-mdast/lib/handlers/text.js","../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../node_modules/hast-util-to-mdast/lib/handlers/a.js","../node_modules/hast-util-to-mdast/lib/handlers/base.js","../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../node_modules/hast-util-to-mdast/lib/handlers/br.js","../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../node_modules/hast-util-to-mdast/lib/handlers/q.js","../node_modules/hast-util-to-mdast/lib/handlers/select.js","../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../node_modules/hast-util-to-mdast/node_modules/rehype-minify-whitespace/block.js","../node_modules/hast-util-to-mdast/node_modules/rehype-minify-whitespace/content.js","../node_modules/hast-util-to-mdast/node_modules/rehype-minify-whitespace/skippable.js","../node_modules/hast-util-to-mdast/node_modules/rehype-minify-whitespace/index.js","../node_modules/hast-util-to-mdast/node_modules/hast-util-whitespace/index.js","../node_modules/hast-util-to-mdast/lib/index.js","../node_modules/rehype-remark/lib/index.js"],"sourcesContent":["export const own = {}.hasOwnProperty\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string} value\n * @returns {string}\n */\nexport function wrapText(h, value) {\n  return h.wrapText ? value : value.replace(/\\r?\\n|\\r/g, ' ')\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Handle} Handle\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {all} from './all.js'\nimport {own} from './util/own.js'\nimport {wrapText} from './util/wrap-text.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @param {Parent|undefined} parent\n * @returns {MdastNode|Array<MdastNode>|void}\n */\nexport function one(h, node, parent) {\n  /** @type {Handle|undefined} */\n  let fn\n\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(h.handlers, node.tagName)) {\n      fn = h.handlers[node.tagName]\n    }\n  } else if (own.call(h.handlers, node.type)) {\n    fn = h.handlers[node.type]\n  }\n\n  if (typeof fn === 'function') {\n    return fn(h, node, parent)\n  }\n\n  return unknown(h, node)\n}\n\n/**\n * @type {Handle}\n * @param {Node} node\n */\nfunction unknown(h, node) {\n  // @ts-expect-error: Looks like a literal.\n  if (typeof node.value === 'string') {\n    // @ts-expect-error: Looks like a literal.\n    return h(node, 'text', wrapText(h, node.value))\n  }\n\n  return all(h, node)\n}\n","/**\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').MdastNode} MdastNode\n */\n\nimport {one} from './one.js'\n\n/**\n * @param {H} h\n * @param {Node} parent\n * @returns {Array<MdastNode>}\n */\nexport function all(h, parent) {\n  /** @type {Array<Node>} */\n  // @ts-expect-error Assume `parent` is a parent.\n  const nodes = parent.children || []\n  /** @type {Array<MdastNode>} */\n  const values = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    // @ts-expect-error assume `parent` is a parent.\n    const result = one(h, nodes[index], parent)\n\n    if (Array.isArray(result)) {\n      values.push(...result)\n    } else if (result) {\n      values.push(result)\n    }\n  }\n\n  let start = 0\n  let end = values.length\n\n  while (start < end && values[start].type === 'break') {\n    start++\n  }\n\n  while (end > start && values[end - 1].type === 'break') {\n    end--\n  }\n\n  return start === 0 && end === values.length\n    ? values\n    : values.slice(start, end)\n}\n","/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport const isElement =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node`is an element and has a `field` property.\n *\n * @param {unknown} node\n *   Thing to check (typically `Element`).\n * @param {unknown} field\n *   Field name to check (typically `string`).\n * @returns {boolean}\n *   Whether `node` is an element that has a `field` property.\n */\nexport function hasProperty(node, field) {\n  const value =\n    typeof field === 'string' &&\n    isNode(node) &&\n    node.type === 'element' &&\n    node.properties &&\n    own.call(node.properties, field) &&\n    node.properties[field]\n\n  return value !== null && value !== undefined && value !== false\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction isNode(value) {\n  return Boolean(value && typeof value === 'object' && 'type' in value)\n}\n","/**\n * @typedef {import('hast').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\n\n/**\n * Check if a node is a *embedded content*.\n *\n * @type {import('hast-util-is-element').AssertPredicate<Element & {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}>}\n * @param value\n *   Thing to check (typically `Node`).\n * @returns\n *   Whether `value` is an element considered embedded content.\n *\n *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,\n *   `object`, `picture`, `svg`, and `video` are embedded content.\n */\n// @ts-expect-error Sure, the assertion matches.\nexport const embedded = convertElement([\n  'audio',\n  'canvas',\n  'embed',\n  'iframe',\n  'img',\n  'math',\n  'object',\n  'picture',\n  'svg',\n  'video'\n])\n","/**\n * @fileoverview\n *   Check if a `link` element is “Body OK”.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {isBodyOkLink} from 'hast-util-is-body-ok-link'\n *\n *   isBodyOkLink(h('link', {itemProp: 'foo'})) //=> true\n *   isBodyOkLink(h('link', {rel: ['stylesheet'], href: 'index.css'})) //=> true\n *   isBodyOkLink(h('link', {rel: ['author'], href: 'index.css'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isBodyOkLink(node)`\n *\n *   * Return `true` for `link` elements with an `itemProp`\n *   * Return `true` for `link` elements with a `rel` list where one or more\n *     entries are `pingback`, `prefetch`, or `stylesheet`.\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst list = new Set(['pingback', 'prefetch', 'stylesheet'])\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if a `link` element is “Body OK”.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isBodyOkLink(node) {\n  if (!isElement(node, 'link')) {\n    return false\n  }\n\n  if (hasProperty(node, 'itemProp')) {\n    return true\n  }\n\n  const props = node.properties || {}\n  const rel = props.rel || []\n  let index = -1\n\n  if (!Array.isArray(rel) || rel.length === 0) {\n    return false\n  }\n\n  while (++index < rel.length) {\n    if (!list.has(String(rel[index]))) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {embedded} from 'hast-util-embedded'\nimport {isBodyOkLink} from 'hast-util-is-body-ok-link'\n\nconst basic = convertElement([\n  'a',\n  'abbr',\n  // `area` is in fact only phrasing if it is inside a `map` element.\n  // However, since `area`s are required to be inside a `map` element, and it’s\n  // a rather involved check, it’s ignored here for now.\n  'area',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'i',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'output',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'wbr'\n])\n\nconst meta = convertElement('meta')\n\n/**\n * Check if the given value is *phrasing* content.\n *\n * @param {unknown} value\n *   Thing to check, typically `Node`.\n * @returns {boolean}\n *   Whether `value` is phrasing content.\n */\nexport function phrasing(value) {\n  return Boolean(\n    node(value) &&\n      (value.type === 'text' ||\n        basic(value) ||\n        embedded(value) ||\n        isBodyOkLink(value) ||\n        (meta(value) && hasProperty(value, 'itemProp')))\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction node(value) {\n  // @ts-expect-error: looks like an object.\n  return value && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n */\n\nimport extend from 'extend'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Array<MdastNode>} nodes\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing)\n\n  /**\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode|Array<MdastNode>}\n   */\n  function onphrasing(nodes) {\n    const head = nodes[0]\n\n    if (\n      nodes.length === 1 &&\n      head.type === 'text' &&\n      (head.value === ' ' || head.value === '\\n')\n    ) {\n      return []\n    }\n\n    return {type: 'paragraph', children: nodes}\n  }\n}\n\n/**\n * Check if there are non-phrasing mdast nodes returned.\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @param {(nodes: Array<MdastPhrasingContent>) => MdastNode|Array<MdastNode>} onphrasing\n * @param {(node: MdastNode) => MdastNode} [onnonphrasing]\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const nonphrasing = onnonphrasing || identity\n  /** @type {Array<MdastNode>} */\n  const flattened = flatten(nodes)\n  /** @type {Array<MdastNode>} */\n  let result = []\n  let index = -1\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < flattened.length) {\n    node = flattened[index]\n\n    if (phrasing(node)) {\n      if (!queue) queue = []\n      queue.push(node)\n    } else {\n      if (queue) {\n        result = result.concat(onphrasing(queue))\n        queue = undefined\n      }\n\n      result = result.concat(nonphrasing(node))\n    }\n  }\n\n  if (queue) {\n    result = result.concat(onphrasing(queue))\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<MdastNode>} nodes\n * @returns {Array<MdastNode>}\n */\nfunction flatten(nodes) {\n  /** @type {Array<MdastNode>} */\n  let flattened = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n\n  while (++index < nodes.length) {\n    node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened = flattened.concat(split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * @param {MdastNode} node\n * @returns {Array<MdastNode>}\n */\nfunction split(node) {\n  // @ts-expect-error Assume parent.\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {MdastNode} child\n   * @returns {MdastNode}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const {children, ...rest} = node\n      return {\n        ...child,\n        // @ts-expect-error: assume matching parent & child.\n        children: [{...extend(true, {}, rest), children: child.children}]\n      }\n    }\n\n    return {...child}\n  }\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<MdastPhrasingContent>} nodes\n   * @returns {MdastNode}\n   */\n  function onphrasing(nodes) {\n    // @ts-expect-error: assume parent.\n    const {children, ...rest} = node\n    // @ts-expect-error: assume matching parent & child.\n    return {...extend(true, {}, rest), children: nodes}\n  }\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {MdastNode} node\n * @returns {node is MdastPhrasingContent}\n */\nfunction phrasing(node) {\n  return node.data && node.data.hName\n    ? hastPhrasing({\n        type: 'element',\n        tagName: node.data.hName,\n        properties: {},\n        children: []\n      })\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {unknown} T\n * @param {T} n\n * @returns {T}\n */\nfunction identity(n) {\n  return n\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\nimport {wrap} from './wrap.js'\n\n/**\n * @param {H} h\n * @param {Node} node\n * @returns {Array<MdastNode>}\n */\nexport function wrapChildren(h, node) {\n  return wrap(all(h, node))\n}\n","/**\n * @typedef {import('../types.js').H} H\n */\n\n/**\n * @param {H} h\n * @param {string|null|undefined} url\n * @returns {string}\n */\nexport function resolve(h, url) {\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (h.frozenBaseUrl) {\n    return String(new URL(url, h.frozenBaseUrl))\n  }\n\n  return url\n}\n","/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport const isElement =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n\n * @param parent\n *   Parent node.\n * @param index\n *   Child of `parent` or it’s index.\n * @param test\n *   `unist-util-is`-compatible test.\n * @returns\n *   Child of `parent` or `null`.\n */\nexport const findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &\n   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent\n     * @param {Node | number} index\n     * @param {Test} [test]\n     * @returns {Node | null}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n","/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any node.\n * @typedef {Extract<Node, import('unist').Parent>} Parent\n *   Any parent.\n * @typedef {'normal' | 'pre' | 'nowrap' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` — space\n *   *   `1` — line ending\n *   *   `2` — blank line\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n * @typedef {BreakValue | BreakNumber | undefined} BreakBefore\n *   Any value for a break before.\n * @typedef {BreakValue | BreakNumber | BreakForce | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > we’re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Node} tree\n *   Tree to turn into text.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options = {}) {\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<string | BreakNumber>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      // @ts-expect-error Looks like a parent.\n      ...innerTextCollection(children[index], tree, {\n        whitespace,\n        breakBefore: index ? undefined : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {Node} node\n * @param {Parent} parent\n * @param {CollectionInfo} info\n * @returns {Array<string | BreakNumber>}\n */\nfunction innerTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parent} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<string | BreakNumber>} */\n  let items = []\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakNumber | BreakForce | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Text | Comment} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<string | BreakNumber>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // […] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as “pre” whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Node} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return props.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return props.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst prefix = 'language-'\n\nconst pre = convertElement('pre')\nconst isCode = convertElement('code')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function code(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<string|number>|undefined} */\n  let classList\n  /** @type {string|undefined} */\n  let lang\n\n  if (pre(node)) {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        isCode(child) &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  return h(\n    node,\n    'code',\n    {lang: lang || null, meta: null},\n    trimTrailingLines(wrapText(h, toText(node)))\n  )\n}\n","/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function del(h, node) {\n  return h(node, 'delete', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\n/**\n * @param {Array<MdastListContent>} children\n * @returns {boolean}\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n */\n\nimport {all} from '../all.js'\n\n/**\n * @param {H} h\n * @param {Child} node\n * @returns {Array<MdastListContent>}\n */\nexport function wrapListItems(h, node) {\n  const children = all(h, node)\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (child.type !== 'listItem') {\n      children[index] = {\n        type: 'listItem',\n        spread: false,\n        checked: null,\n        // @ts-expect-error Assume `children[index]` is block content.\n        children: [child]\n      }\n    }\n  }\n\n  // @ts-expect-error Assume all `listItem`s\n  return children\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastListContent} MdastListContent\n * @typedef {import('../types.js').MdastBlockContent} MdastBlockContent\n * @typedef {import('../types.js').MdastDefinitionContent} MdastDefinitionContent\n *\n * @typedef Group\n * @property {Array<Element>} titles\n * @property {Array<ElementChild>} definitions\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst div = convertElement('div')\nconst dt = convertElement('dt')\nconst dd = convertElement('dd')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function dl(h, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<ElementChild>} */\n  let clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  /** @type {Group} */\n  let group = {titles: [], definitions: []}\n  /** @type {ElementChild} */\n  let child\n  /** @type {Array<MdastBlockContent|MdastDefinitionContent>} */\n  let result\n\n  // Unwrap `<div>`s\n  while (++index < children.length) {\n    child = children[index]\n    clean = clean.concat(div(child) ? child.children : child)\n  }\n\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    child = clean[index]\n\n    if (dt(child)) {\n      if (dd(clean[index - 1])) {\n        groups.push(group)\n        group = {titles: [], definitions: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<MdastListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    result = [\n      ...handle(h, groups[index].titles),\n      ...handle(h, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    return h(\n      node,\n      'list',\n      {ordered: false, start: null, spread: listItemsSpread(content)},\n      content\n    )\n  }\n}\n\n/**\n * @param {H} h\n * @param {Array<ElementChild>} children\n * @returns {Array<MdastBlockContent|MdastDefinitionContent>}\n */\nfunction handle(h, children) {\n  const nodes = wrapListItems(h, {type: 'element', tagName: 'x', children})\n\n  if (nodes.length === 0) {\n    return []\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(nodes),\n      children: nodes\n    }\n  ]\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function em(h, node) {\n  return h(node, 'emphasis', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function heading(h, node) {\n  // `else` shouldn’t happen, of course…\n  /* c8 ignore next */\n  const depth = Number(node.tagName.charAt(1)) || 1\n  const wrap = h.wrapText\n\n  h.wrapText = false\n  const result = h(node, 'heading', {depth}, all(h, node))\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function img(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(node, 'image', {\n    url: resolve(h, String(props.src || '') || null),\n    title: props.title || null,\n    alt: props.alt || ''\n  })\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function inlineCode(h, node) {\n  return h(node, 'inlineCode', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').H} H\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Child} Child\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {hasProperty} from 'hast-util-has-property'\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from './wrap-text.js'\n\nconst option = convertElement('option')\n\n/**\n * @param {H} h\n * @param {Element} node\n * @param {Properties} [properties]\n * @returns {Array<[string, string|null]>}\n */\nexport function findSelectedOptions(h, node, properties) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` exist.\n  const props = properties || node.properties\n  let options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(props.size), 10), 0) ||\n    (props.multiple ? 4 : 1)\n  let index = -1\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Array<[string, string|null]>} */\n  const values = []\n\n  while (++index < options.length) {\n    if (hasProperty(options[index], 'selected')) {\n      selectedOptions.push(options[index])\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  options = list.slice(0, size)\n  index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n    const content = wrapText(h, toText(option))\n    /** @type {Properties} */\n    // @ts-expect-error: `props` exist.\n    const props = option.properties\n    const label = content || String(props.label || '')\n    const value = String(props.value || '') || content\n    values.push([value, label === value ? null : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Parent} node\n */\nfunction findOptions(node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<Element>} */\n  let results = []\n  /** @type {Child} */\n  let child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    // @ts-expect-error Looks like a parent.\n    if (Array.isArray(child.children)) {\n      // @ts-expect-error Looks like a parent.\n      results = results.concat(findOptions(child))\n    }\n\n    if (option(child) && !hasProperty(child, 'disabled')) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {own} from '../util/own.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\nconst datalist = convertElement('datalist')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\n// eslint-disable-next-line complexity\nexport function input(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  let value = String(props.value || props.placeholder || '')\n  /** @type {Array<MdastNode>} */\n  const results = []\n  /** @type {Array<string>} */\n  const texts = []\n  /** @type {Array<[string, string|null]>} */\n  let values = []\n  let index = -1\n  /** @type {string} */\n  let list\n\n  if (props.disabled || props.type === 'hidden' || props.type === 'file') {\n    return\n  }\n\n  if (props.type === 'checkbox' || props.type === 'radio') {\n    return h(\n      node,\n      'text',\n      wrapText(h, h[props.checked ? 'checked' : 'unchecked'])\n    )\n  }\n\n  if (props.type === 'image') {\n    return props.alt || value\n      ? h(node, 'image', {\n          url: resolve(h, String(props.src || '') || null),\n          title: wrapText(h, String(props.title || '')) || null,\n          alt: wrapText(h, String(props.alt || value))\n        })\n      : []\n  }\n\n  if (value) {\n    values = [[value, null]]\n  } else if (\n    // `list` is not supported on these types:\n    props.type !== 'password' &&\n    props.type !== 'file' &&\n    props.type !== 'submit' &&\n    props.type !== 'reset' &&\n    props.type !== 'button' &&\n    props.list\n  ) {\n    list = String(props.list).toUpperCase()\n\n    if (own.call(h.nodeById, list) && datalist(h.nodeById[list])) {\n      values = findSelectedOptions(h, h.nodeById[list], props)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (props.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), null]\n  }\n\n  if (props.type === 'url' || props.type === 'email') {\n    while (++index < values.length) {\n      value = resolve(h, values[index][0])\n\n      results.push(\n        h(\n          node,\n          'link',\n          {\n            title: null,\n            url: wrapText(h, props.type === 'email' ? 'mailto:' + value : value)\n          },\n          [{type: 'text', value: wrapText(h, values[index][1] || value)}]\n        )\n      )\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  return h(node, 'text', wrapText(h, texts.join(', ')))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').ElementChild} ElementChild\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {wrapChildren} from '../util/wrap-children.js'\n\nconst p = convertElement('p')\nconst input = convertElement('input')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function li(h, node) {\n  const head = node.children[0]\n  /** @type {boolean|null} */\n  let checked = null\n  /** @type {ElementChild} */\n  let checkbox\n  /** @type {Element|undefined} */\n  let clone\n\n  // Check if this node starts with a checkbox.\n  if (p(head)) {\n    checkbox = head.children[0]\n\n    if (\n      input(checkbox) &&\n      checkbox.properties &&\n      (checkbox.properties.type === 'checkbox' ||\n        checkbox.properties.type === 'radio')\n    ) {\n      checked = Boolean(checkbox.properties.checked)\n      clone = {\n        ...node,\n        children: [\n          {...head, children: head.children.slice(1)},\n          ...node.children.slice(1)\n        ]\n      }\n    }\n  }\n\n  const content = wrapChildren(h, clone || node)\n\n  return h(node, 'listItem', {spread: content.length > 1, checked}, content)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {listItemsSpread} from '../util/list-items-spread.js'\nimport {wrapListItems} from '../util/wrap-list-items.js'\n\nconst ol = convertElement('ol')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function list(h, node) {\n  const ordered = ol(node)\n  const children = wrapListItems(h, node)\n  /** @type {number|null} */\n  let start = null\n\n  if (ordered) {\n    start = hasProperty(node, 'start')\n      ? // @ts-expect-error: `props` exist.\n        Number.parseInt(String(node.properties.start), 10)\n      : 1\n  }\n\n  return h(\n    node,\n    'list',\n    {ordered, start, spread: listItemsSpread(children)},\n    children\n  )\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').ElementChild} ElementChild\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toString} from 'mdast-util-to-string'\nimport {visit, EXIT} from 'unist-util-visit'\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\nimport {wrapNeeded} from '../util/wrap.js'\n\nconst source = convertElement('source')\nconst video = convertElement('video')\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function media(h, node) {\n  let nodes = all(h, node)\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const properties = node.properties\n  const poster = video(node) && String(properties.poster || '')\n  let src = String(properties.src || '')\n  let index = -1\n  /** @type {boolean} */\n  let linkInFallbackContent = false\n  /** @type {ElementChild} */\n  let child\n\n  visit({type: 'root', children: nodes}, 'link', findLink)\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!src && ++index < node.children.length) {\n    child = node.children[index]\n    if (source(child)) {\n      // @ts-expect-error: `props` are defined.\n      src = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    nodes = [\n      {\n        type: 'image',\n        title: null,\n        url: resolve(h, poster),\n        alt: toString({children: nodes})\n      }\n    ]\n  }\n\n  // Link to the media resource.\n  return {\n    type: 'link',\n    // @ts-expect-error Types are broken.\n    title: node.properties.title || null,\n    url: resolve(h, src),\n    // @ts-expect-error Assume phrasing content.\n    children: nodes\n  }\n\n  function findLink() {\n    linkInFallbackContent = true\n    return EXIT\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function p(h, node) {\n  const nodes = all(h, node)\n\n  if (nodes.length > 0) {\n    return h(node, 'paragraph', nodes)\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function strong(h, node) {\n  return h(node, 'strong', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableCell(h, node) {\n  const wrap = h.wrapText\n\n  h.wrapText = false\n\n  const result = h(node, 'tableCell', all(h, node))\n\n  if (node.properties && (node.properties.rowSpan || node.properties.colSpan)) {\n    const data = result.data || (result.data = {})\n    if (node.properties.rowSpan) data.rowSpan = node.properties.rowSpan\n    if (node.properties.colSpan) data.colSpan = node.properties.colSpan\n  }\n\n  h.wrapText = wrap\n\n  return result\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n * @typedef {import('../types.js').MdastTableContent} MdastTableContent\n * @typedef {import('../types.js').MdastRowContent} MdastRowContent\n * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent\n *\n * @typedef Info\n * @property {Array<string|null>} align\n * @property {boolean} headless\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {toText} from 'hast-util-to-text'\nimport {visit, SKIP} from 'unist-util-visit'\nimport {wrapText} from '../util/wrap-text.js'\nimport {all} from '../all.js'\n\nconst thead = convertElement('thead')\nconst tr = convertElement('tr')\nconst cell = convertElement(['th', 'td'])\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function table(h, node) {\n  if (h.inTable) {\n    return h(node, 'text', wrapText(h, toText(node)))\n  }\n\n  h.inTable = true\n\n  const {headless, align} = inspect(node)\n  const rows = toRows(all(h, node), headless)\n  let columns = 1\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const colSpan = Number.parseInt(String(cell.data.colSpan), 10) || 1\n        const rowSpan = Number.parseInt(String(cell.data.rowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<MdastRowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('colSpan' in cell.data) delete cell.data.colSpan\n        if ('rowSpan' in cell.data) delete cell.data.rowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  h.inTable = false\n\n  return h(node, 'table', {align}, rows)\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Element} node\n * @returns {Info}\n */\nfunction inspect(node) {\n  let headless = true\n  let rowIndex = 0\n  let cellIndex = 0\n  /** @type {Array<string|null>} */\n  const align = [null]\n\n  visit(node, 'element', (child) => {\n    if (child.tagName === 'table' && node !== child) {\n      return SKIP\n    }\n\n    // If there is a `thead`, assume there is a header row.\n    if (cell(child) && child.properties) {\n      if (!align[cellIndex]) {\n        align[cellIndex] = String(child.properties.align || '') || null\n      }\n\n      // If there is a th in the first row, assume there is a header row.\n      if (headless && rowIndex < 2 && child.tagName === 'th') {\n        headless = false\n      }\n\n      cellIndex++\n    } else if (thead(child)) {\n      headless = false\n    } else if (tr(child)) {\n      rowIndex++\n      cellIndex = 0\n    }\n  })\n\n  return {align, headless}\n}\n\n/**\n * Ensure the rows are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @param {boolean} headless\n * @returns {Array<MdastTableContent>}\n */\nfunction toRows(children, headless) {\n  let index = -1\n  /** @type {Array<MdastTableContent>} */\n  const nodes = []\n  /** @type {Array<MdastRowContent>|undefined} */\n  let queue\n\n  // Add an empty header row.\n  if (headless) {\n    nodes.push({type: 'tableRow', children: []})\n  }\n\n  while (++index < children.length) {\n    const node = children[index]\n\n    if (node.type === 'tableRow') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume row content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    nodes[nodes.length - 1].children.push(...queue)\n  }\n\n  index = -1\n\n  while (++index < nodes.length) {\n    nodes[index].children = toCells(nodes[index].children)\n  }\n\n  return nodes\n}\n\n/**\n * Ensure the cells in a row are properly structured.\n *\n * @param {Array<MdastNode>} children\n * @returns {Array<MdastRowContent>}\n */\nfunction toCells(children) {\n  /** @type {Array<MdastRowContent>} */\n  const nodes = []\n  let index = -1\n  /** @type {MdastNode} */\n  let node\n  /** @type {Array<MdastPhrasingContent>|undefined} */\n  let queue\n\n  while (++index < children.length) {\n    node = children[index]\n\n    if (node.type === 'tableCell') {\n      if (queue) {\n        node.children.unshift(...queue)\n        queue = undefined\n      }\n\n      nodes.push(node)\n    } else {\n      if (!queue) queue = []\n      // @ts-expect-error Assume phrasing content.\n      queue.push(node)\n    }\n  }\n\n  if (queue) {\n    node = nodes[nodes.length - 1]\n\n    if (!node) {\n      node = {type: 'tableCell', children: []}\n      nodes.push(node)\n    }\n\n    node.children.push(...queue)\n  }\n\n  return nodes\n}\n","import {all} from '../all.js'\nimport {wrapChildren} from '../util/wrap-children.js'\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\nexport const handlers = {\n  root,\n  text,\n  comment,\n  doctype: ignore,\n\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  address: wrapChildren,\n  article: wrapChildren,\n  aside: wrapChildren,\n  body: wrapChildren,\n  center: wrapChildren,\n  div: wrapChildren,\n  fieldset: wrapChildren,\n  figcaption: wrapChildren,\n  figure: wrapChildren,\n  form: wrapChildren,\n  footer: wrapChildren,\n  header: wrapChildren,\n  hgroup: wrapChildren,\n  html: wrapChildren,\n  legend: wrapChildren,\n  main: wrapChildren,\n  multicol: wrapChildren,\n  nav: wrapChildren,\n  picture: wrapChildren,\n  section: wrapChildren,\n\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\nfunction ignore() {}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Root} Root\n */\n\nimport {all} from '../all.js'\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @type {Handle}\n * @param {Root} node\n */\nexport function root(h, node) {\n  let children = all(h, node)\n\n  if (h.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  return h(node, 'root', children)\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Text} Text\n */\n\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(h, node) {\n  return h(node, 'text', wrapText(h, node.value))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Comment} Comment\n */\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Comment} node\n */\nexport function comment(h, node) {\n  return h(node, 'html', '<!--' + wrapText(h, node.value) + '-->')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {all} from '../all.js'\nimport {resolve} from '../util/resolve.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function a(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  return h(\n    node,\n    'link',\n    {\n      title: props.title || null,\n      url: resolve(h, String(props.href || '') || null)\n    },\n    all(h, node)\n  )\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function base(h, node) {\n  if (!h.baseFound) {\n    h.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || null\n    h.baseFound = true\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {wrapChildren} from '../util/wrap-children.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function blockquote(h, node) {\n  return h(node, 'blockquote', wrapChildren(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function br(h, node) {\n  return h.wrapText ? h(node, 'break') : h(node, 'text', ' ')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function hr(h, node) {\n  return h(node, 'thematicBreak')\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n */\n\nimport {resolve} from '../util/resolve.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function iframe(h, node) {\n  /** @type {Properties} */\n  // @ts-expect-error: `props` are defined.\n  const props = node.properties\n  const src = String(props.src || '')\n  const title = String(props.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (src && title) {\n    return {\n      type: 'link',\n      title: null,\n      url: resolve(h, src),\n      children: [{type: 'text', value: wrapText(h, title)}]\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').MdastNode} MdastNode\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function q(h, node) {\n  const expected = h.quotes[h.qNesting % h.quotes.length]\n\n  h.qNesting++\n  const contents = all(h, node)\n  h.qNesting--\n\n  contents.unshift({type: 'text', value: expected.charAt(0)})\n\n  contents.push({\n    type: 'text',\n    value: expected.length > 1 ? expected.charAt(1) : expected\n  })\n\n  return contents\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function select(h, node) {\n  const values = findSelectedOptions(h, node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n  /** @type {[string, string|null]} */\n  let value\n\n  while (++index < values.length) {\n    value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    return h(node, 'text', wrapText(h, results.join(', ')))\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {wrapText} from '../util/wrap-text.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function textarea(h, node) {\n  return h(node, 'text', wrapText(h, toText(node)))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\nimport {all} from '../all.js'\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function tableRow(h, node) {\n  return h(node, 'tableRow', all(h, node))\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Element} Element\n */\n\n/**\n * @type {Handle}\n * @param {Element} node\n */\nexport function wbr(h, node) {\n  return h(node, 'text', '\\u200B')\n}\n","// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nexport const blocks = [\n  'address', // Flow content.\n  'article', // Sections and headings.\n  'aside', // Sections and headings.\n  'blockquote', // Flow content.\n  'body', // Page.\n  'br', // Contribute whitespace intrinsically.\n  'caption', // Similar to block.\n  'center', // Flow content, legacy.\n  'col', // Similar to block.\n  'colgroup', // Similar to block.\n  'dd', // Lists.\n  'dialog', // Flow content.\n  'dir', // Lists, legacy.\n  'div', // Flow content.\n  'dl', // Lists.\n  'dt', // Lists.\n  'figcaption', // Flow content.\n  'figure', // Flow content.\n  'footer', // Flow content.\n  'form', // Flow content.\n  'h1', // Sections and headings.\n  'h2', // Sections and headings.\n  'h3', // Sections and headings.\n  'h4', // Sections and headings.\n  'h5', // Sections and headings.\n  'h6', // Sections and headings.\n  'head', // Page.\n  'header', // Flow content.\n  'hgroup', // Sections and headings.\n  'hr', // Flow content.\n  'html', // Page.\n  'legend', // Flow content.\n  'li', // Block-like.\n  'li', // Similar to block.\n  'listing', // Flow content, legacy\n  'main', // Flow content.\n  'menu', // Lists.\n  'nav', // Sections and headings.\n  'ol', // Lists.\n  'optgroup', // Similar to block.\n  'option', // Similar to block.\n  'p', // Flow content.\n  'plaintext', // Flow content, legacy\n  'pre', // Flow content.\n  'section', // Sections and headings.\n  'summary', // Similar to block.\n  'table', // Similar to block.\n  'tbody', // Similar to block.\n  'td', // Block-like.\n  'td', // Similar to block.\n  'tfoot', // Similar to block.\n  'th', // Block-like.\n  'th', // Similar to block.\n  'thead', // Similar to block.\n  'tr', // Similar to block.\n  'ul', // Lists.\n  'wbr', // Contribute whitespace intrinsically.\n  'xmp' // Flow content, legacy\n]\n","export const content = [\n  // Form.\n  'button',\n  'input',\n  'select',\n  'textarea'\n]\n","export const skippable = [\n  'area',\n  'base',\n  'basefont',\n  'dialog',\n  'datalist',\n  'head',\n  'link',\n  'meta',\n  'noembed',\n  'noframes',\n  'param',\n  'rp',\n  'script',\n  'source',\n  'style',\n  'template',\n  'track',\n  'title'\n]\n","/**\n * rehype plugin to minify whitespace between elements.\n *\n * ## What is this?\n *\n * This package is a plugin that can minify the whitespace between elements.\n *\n * ## When should I use this?\n *\n * You can use this plugin when you want to improve the size of HTML documents.\n *\n * ## API\n *\n * ### `unified().use(rehypeMinifyWhitespace[, options])`\n *\n * Minify whitespace.\n *\n * ##### `options`\n *\n * Configuration (optional).\n *\n * ##### `options.newlines`\n *\n * Whether to collapse runs of whitespace that include line endings to one\n * line ending (`boolean`, default: `false`).\n * The default is to collapse everything to one space.\n *\n * @example\n *   <h1>Heading</h1>\n *   <p><strong>This</strong> and <em>that</em></p>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Root|Root['children'][number]} Node\n *\n * @typedef Options\n * @property {boolean} [newlines=false]\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n *   The default is to collapse to a single space.\n *\n * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace\n *\n * @typedef Context\n * @property {ReturnType<collapseFactory>} collapse\n * @property {Whitespace} whitespace\n * @property {boolean} [before]\n * @property {boolean} [after]\n *\n * @typedef Result\n * @property {boolean} remove\n * @property {boolean} ignore\n * @property {boolean} stripAtStart\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {embedded} from 'hast-util-embedded'\nimport {convert} from 'unist-util-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Minify whitespace.\n *\n * @type {import('unified').Plugin<[Options?]|Array<void>, Root>}\n */\nexport default function rehypeMinifyWhitespace(options = {}) {\n  const collapse = collapseFactory(\n    options.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  return (tree) => {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minify(node, context) {\n  if ('children' in node) {\n    const settings = Object.assign({}, context)\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, context)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (context.whitespace === 'normal') {\n      return minifyText(node, context)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (context.whitespace === 'nowrap') {\n      node.value = context.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {remove: false, ignore: ignorableNode(node), stripAtStart: false}\n}\n\n/**\n * @param {Text} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minifyText(node, context) {\n  const value = context.collapse(node.value)\n  const result = {remove: false, ignore: false, stripAtStart: false}\n  let start = 0\n  let end = value.length\n\n  if (context.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (context.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Root|Element} parent\n * @param {Context} context\n * @returns {Result}\n */\nfunction all(parent, context) {\n  let before = context.before\n  const after = context.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(\n      children[index],\n      Object.assign({}, context, {\n        before,\n        after: collapsableAfter(children, index, after)\n      })\n    )\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {remove: false, ignore: false, stripAtStart: Boolean(before || after)}\n}\n\n/**\n * @param {Array<Node>} nodes\n * @param {number} index\n * @param {boolean|undefined} [after]\n * @returns {boolean|undefined}\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Node} node\n * @returns {boolean|undefined}\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Element} node\n * @returns {boolean}\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {boolean}\n */\nfunction skippable(node) {\n  return (\n    Boolean(\n      'properties' in node && node.properties && node.properties.hidden\n    ) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n * @returns {boolean}\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @returns {string}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {(value: string) => string} replace\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Root|Element} node\n * @param {Context} context\n * @returns {Whitespace}\n */\nfunction inferWhiteSpace(node, context) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return node.properties.noWrap ? 'nowrap' : context.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return context.whitespace\n}\n","/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Properties} Properties\n * @typedef {import('./types.js').H} H\n * @typedef {import('./types.js').HWithoutProps} HWithoutProps\n * @typedef {import('./types.js').HWithProps} HWithProps\n * @typedef {import('./types.js').MdastNode} MdastNode\n * @typedef {import('./types.js').MdastRoot} MdastRoot\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {convert} from 'unist-util-is'\nimport {visit} from 'unist-util-visit'\nimport {one} from './one.js'\nimport {handlers} from './handlers/index.js'\nimport {own} from './util/own.js'\n\nexport {one} from './one.js'\nexport {all} from './all.js'\n\nconst block = convert(['heading', 'paragraph', 'root'])\n\n/**\n * Transform hast to mdast.\n *\n * @param {Node} tree\n *   Tree (hast).\n * @param {Options} [options]\n *   Configuration (optional).\n */\nexport function toMdast(tree, options = {}) {\n  /** @type {Record<string, Element>} */\n  const byId = {}\n  /** @type {MdastNode|MdastRoot} */\n  let mdast\n\n  /**\n   * @type {H}\n   */\n  const h = Object.assign(\n    /**\n     * @type {HWithProps & HWithoutProps}\n     */\n    (\n      /**\n       * @param {Node} node\n       * @param {string} type\n       * @param {Properties|string|Array<Node>} [props]\n       * @param {string|Array<Node>} [children]\n       */\n      (node, type, props, children) => {\n        /** @type {Properties|undefined} */\n        let properties\n\n        if (typeof props === 'string' || Array.isArray(props)) {\n          children = props\n          properties = {}\n        } else {\n          properties = props\n        }\n\n        /** @type {Node} */\n        // @ts-expect-error Assume valid `type` and `children`/`value`.\n        const result = {type, ...properties}\n\n        if (typeof children === 'string') {\n          // @ts-expect-error: Looks like a literal.\n          result.value = children\n        } else if (children) {\n          // @ts-expect-error: Looks like a parent.\n          result.children = children\n        }\n\n        if (node.position) {\n          result.position = node.position\n        }\n\n        return result\n      }\n    ),\n    {\n      nodeById: byId,\n      baseFound: false,\n      inTable: false,\n      wrapText: true,\n      /** @type {string|null} */\n      frozenBaseUrl: null,\n      qNesting: 0,\n      handlers: options.handlers\n        ? {...handlers, ...options.handlers}\n        : handlers,\n      document: options.document,\n      checked: options.checked || '[x]',\n      unchecked: options.unchecked || '[ ]',\n      quotes: options.quotes || ['\"']\n    }\n  )\n\n  visit(tree, 'element', (node) => {\n    const id =\n      node.properties &&\n      'id' in node.properties &&\n      String(node.properties.id).toUpperCase()\n\n    if (id && !own.call(byId, id)) {\n      byId[id] = node\n    }\n  })\n\n  // @ts-expect-error: does return a transformer, that does accept any node.\n  rehypeMinifyWhitespace({newlines: options.newlines === true})(tree)\n\n  const result = one(h, tree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    mdast = {type: 'root', children: result}\n  } else {\n    mdast = result\n  }\n\n  visit(mdast, 'text', ontext)\n\n  return mdast\n\n  /**\n   * Collapse text nodes, and fix whitespace.\n   * Most of this is taken care of by `rehype-minify-whitespace`, but\n   * we’re generating some whitespace too, and some nodes are in the end\n   * ignored.\n   * So clean up.\n   *\n   * @type {import('unist-util-visit/complex-types').BuildVisitor<MdastRoot, 'text'>}\n   */\n  function ontext(node, index, parent) {\n    /* c8 ignore next 3 */\n    if (index === null || !parent) {\n      return\n    }\n\n    const previous = parent.children[index - 1]\n\n    if (previous && previous.type === node.type) {\n      previous.value += node.value\n      parent.children.splice(index, 1)\n\n      if (previous.position && node.position) {\n        previous.position.end = node.position.end\n      }\n\n      // Iterate over the previous node again, to handle its total value.\n      return index - 1\n    }\n\n    node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n    // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n    // as there the whitespace matters.\n    if (parent && block(parent)) {\n      if (!index) {\n        node.value = node.value.replace(/^[\\t ]+/, '')\n      }\n\n      if (index === parent.children.length - 1) {\n        node.value = node.value.replace(/[\\t ]+$/, '')\n      }\n    }\n\n    if (!node.value) {\n      parent.children.splice(index, 1)\n      return index\n    }\n  }\n}\n\nexport {handlers as defaultHandlers} from './handlers/index.js'\n","/**\n * @typedef {import('hast-util-to-mdast').Options} Options\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/**\n * Plugin to bridge or mutate to rehype.\n *\n * If a destination is given, runs the destination with the new mdast\n * tree (bridge-mode).\n * Without destination, returns the mdast tree: further plugins run on that\n * tree (mutate-mode).\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `hast-util-to-mdast`.\n */\nconst rehypeRemark =\n  /**\n   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}\n   */\n  (\n    /**\n     * @param {Processor|Options} [destination]\n     * @param {Options} [options]\n     */\n    function (destination, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {Processor|undefined} */\n      let processor\n\n      if (typeof destination === 'function') {\n        processor = destination\n        settings = options || {}\n      } else {\n        settings = destination || {}\n      }\n\n      if (settings.document === undefined || settings.document === null) {\n        settings = Object.assign({}, settings, {document: true})\n      }\n\n      return processor ? bridge(processor, settings) : mutate(settings)\n    }\n  )\n\nexport default rehypeRemark\n\n/**\n * Bridge-mode.\n * Runs the destination with the new mdast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], HastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toMdast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further transformers run on the mdast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>}\n */\nfunction mutate(options = {}) {\n  return (node) => {\n    const result = /** @type {MdastRoot} */ (toMdast(node, options))\n    return result\n  }\n}\n"],"names":["own","hasOwnProperty","wrapText","h","value","replace","one","node","parent","fn","type","properties","dataMdast","call","handlers","tagName","all","unknown","nodes","children","values","index","length","result","Array","isArray","push","start","end","slice","isElement","test","context","check","convertElement","undefined","Number","POSITIVE_INFINITY","Error","element","tagNameFactory","tests","checks","castFactory","any","_len","arguments","parameters","_key","this","anyFactory","_len2","_key2","Boolean","hasProperty","field","isNode","embedded","list","Set","basic","meta","phrasing","rel","has","String","isBodyOkLink","convert","ok","typeFactory","key","propsFactory","wrap","runs","head","wrapNeeded","onphrasing","onnonphrasing","nonphrasing","identity","flattened","concat","split","flatten","queue","rest","extend","child","data","hName","hastPhrasing","mdastPhrasing","n","wrapChildren","resolve","url","frozenBaseUrl","URL","findAfter","is","indexOf","searchLineFeeds","searchTabOrSpaces","br","p","cell","row","notRendered","hidden","open","blockOrCaption","toText","tree","options","block","whitespace","inferWhitespace","breakBefore","breakAfter","results","collectText","innerTextCollection","count","repeat","join","info","prefix","suffix","items","unshift","collectElement","collectPreText","lines","lastIndex","match","exec","trimAndCollapseSpacesAndTabs","charCodeAt","props","noWrap","pre","isCode","code","classList","lang","className","input","codePointAt","trimTrailingLines","del","listItemsSpread","spread","wrapListItems","checked","div","dt","dd","handle","ordered","em","heading","depth","charAt","img","src","title","alt","inlineCode","option","findSelectedOptions","findOptions","size","Math","min","parseInt","multiple","selectedOptions","content","label","datalist","li","checkbox","clone","ol","emptyOptions","toString","settings","includeImageAlt","includeHtml","EXIT","SKIP","visitParents","visitor","reverse","step","factory","parents","name","Object","defineProperty","visit","subresult","offset","grandparents","toResult","source","video","media","poster","linkInFallbackContent","strong","tableCell","rowSpan","colSpan","thead","tr","toCells","root","document","text","comment","doctype","ignore","applet","area","basefont","bgsound","caption","col","colgroup","command","dialog","embed","frame","frameset","isindex","keygen","link","math","menu","menuitem","nextid","noembed","noframes","optgroup","param","script","shadow","spacer","style","svg","template","track","abbr","acronym","bdi","bdo","big","blink","button","canvas","cite","details","dfn","font","ins","map","marquee","meter","nobr","noscript","object","output","progress","rb","rbc","rp","rt","rtc","ruby","slot","small","span","sup","sub","tbody","tfoot","time","address","article","aside","body","center","fieldset","figcaption","figure","form","footer","header","hgroup","html","legend","main","multicol","nav","picture","section","a","href","audio","b","base","baseFound","blockquote","dir","dl","clean","groups","group","titles","definitions","h1","h2","h3","h4","h5","h6","hr","i","iframe","image","placeholder","texts","disabled","toUpperCase","nodeById","kbd","listing","mark","plaintext","q","expected","quotes","qNesting","contents","s","samp","select","strike","summary","table","inTable","headless","align","rowIndex","cellIndex","inspect","rows","toRows","columns","cells","otherRowIndex","colIndex","newCells","splice","keys","alignIndex","td","textarea","th","tt","u","ul","var","wbr","xmp","blocks","skippable","ignorableNode","rehypeMinifyWhitespace","collapse","collapseFactory","newlines","replaceNewlines","replaceWhitespace","minify","assign","blocklike","before","after","inferWhiteSpace","collapsableAfter","remove","stripAtStart","removable","minifyText","inferBoundary","thing","skippables","character","toMdast","byId","mdast","position","unchecked","id","ontext","previous","destination","processor","file","next","run","error","bridge","mutate"],"sourceRoot":""}