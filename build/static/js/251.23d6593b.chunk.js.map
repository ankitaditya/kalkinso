{"version":3,"file":"static/js/251.23d6593b.chunk.js","mappings":"uOAUO,MCaMA,EAAaC,EAAW,YAcxBC,EAAoBD,EAAW,cAuB/BE,EAAaF,EAAW,uBAa9B,SAASG,EAAaC,GAC3B,OAGW,OAATA,IAAkBA,EAAO,IAAe,MAATA,GAe5B,MAAMC,EAAaL,EAAW,MAoBxBM,EAAgBN,EAAW,cAe3BO,EAAmBP,EAAW,kBAiBpC,SAASQ,EAAmBJ,GACjC,OAAgB,OAATA,GAAiBA,GAAQ,EAY3B,SAASK,EAA0BL,GACxC,OAAgB,OAATA,IAAkBA,EAAO,GAAc,KAATA,GAkBhC,SAASM,EAAcN,GAC5B,OAAiB,IAAVA,IAAyB,IAAVA,GAAwB,KAATA,EAwBhC,MAAMO,EAAqBX,ED9LhC,wwCCoNWY,EAAoBZ,EAAW,MAQ5C,SAASA,EAAWa,GAClB,OAUA,SAAeT,GACb,OAAgB,OAATA,GAAiBS,EAAMC,KAAKC,OAAOC,aAAaZ,O,uGCxLpD,SAASa,EAAaC,GAE3B,MAAMC,EAAS,GACf,IAAIC,GAAS,EACTC,EAAQ,EACRC,EAAO,EACX,OAASF,EAAQF,EAAMK,QAAQ,CAC7B,MAAMnB,EAAOc,EAAMM,WAAWJ,GAE9B,IAAIK,EAAU,GAGd,GACW,KAATrB,IACAH,EAAAA,EAAAA,IAAkBiB,EAAMM,WAAWJ,EAAQ,MAC3CnB,EAAAA,EAAAA,IAAkBiB,EAAMM,WAAWJ,EAAQ,IAE3CE,EAAO,OAGJ,GAAIlB,EAAO,IACT,oBAAoBU,KAAKC,OAAOC,aAAaZ,MAChDqB,EAAUV,OAAOC,aAAaZ,SAI7B,GAAIA,EAAO,OAASA,EAAO,MAAO,CACrC,MAAMsB,EAAOR,EAAMM,WAAWJ,EAAQ,GAGlChB,EAAO,OAASsB,EAAO,OAASA,EAAO,OACzCD,EAAUV,OAAOC,aAAaZ,EAAMsB,GACpCJ,EAAO,GAIPG,EAAU,cAKZA,EAAUV,OAAOC,aAAaZ,GAE5BqB,IACFN,EAAOQ,KAAKT,EAAMU,MAAMP,EAAOD,GAAQS,mBAAmBJ,IAC1DJ,EAAQD,EAAQE,EAAO,EACvBG,EAAU,IAERH,IACFF,GAASE,EACTA,EAAO,GAGX,OAAOH,EAAOW,KAAK,IAAMZ,EAAMU,MAAMP,GC9FhC,SAASU,EAAkBC,EAAOC,GACvC,MAAMC,EAAKnB,OAAOkB,EAAKE,YAAYC,cAC7BC,EAASpB,EAAaiB,EAAGI,eACzBlB,EAAQY,EAAMO,cAAcC,QAAQN,GAE1C,IAAIO,GAEW,IAAXrB,GACFY,EAAMO,cAAcZ,KAAKO,GACzBF,EAAMU,eAAeR,GAAM,EAC3BO,EAAUT,EAAMO,cAAchB,SAE9BS,EAAMU,eAAeR,KACrBO,EAAUrB,EAAQ,GAGpB,MAAMuB,EAAeX,EAAMU,eAAeR,GAGpCU,EAAO,CACXC,KAAM,UACNC,QAAS,IACTC,WAAY,CACVC,KAAM,IAAMhB,EAAMiB,cAAgB,MAAQZ,EAC1CH,GACEF,EAAMiB,cACN,SACAZ,GACCM,EAAe,EAAI,IAAMA,EAAe,IAC3CO,iBAAiB,EACjBC,gBAAiB,CAAC,mBAEpBC,SAAU,CAAC,CAACP,KAAM,OAAQ3B,MAAOH,OAAO0B,MAE1CT,EAAMqB,MAAMpB,EAAMW,GAGlB,MAAMU,EAAM,CACVT,KAAM,UACNC,QAAS,MACTC,WAAY,GACZK,SAAU,CAACR,IAGb,OADAZ,EAAMqB,MAAMpB,EAAMqB,GACXtB,EAAMuB,UAAUtB,EAAMqB,GCnCxB,SAASE,EAAOxB,EAAOC,GAC5B,MAAMwB,EAAUxB,EAAKyB,cACrB,IAAIC,EAAS,IAQb,GANgB,cAAZF,EACFE,GAAU,KACW,SAAZF,IACTE,GAAU,KAAO1B,EAAK2B,OAAS3B,EAAKE,YAAc,KAGlC,mBAAdF,EAAKY,KACP,MAAO,CAACA,KAAM,OAAQ3B,MAAO,KAAOe,EAAK4B,IAAMF,GAGjD,MAAMG,EAAW9B,EAAM+B,IAAI9B,GACrB+B,EAAOF,EAAS,GAElBE,GAAsB,SAAdA,EAAKnB,KACfmB,EAAK9C,MAAQ,IAAM8C,EAAK9C,MAExB4C,EAASG,QAAQ,CAACpB,KAAM,OAAQ3B,MAAO,MAGzC,MAAMgD,EAAOJ,EAASA,EAASvC,OAAS,GAQxC,OANI2C,GAAsB,SAAdA,EAAKrB,KACfqB,EAAKhD,OAASyC,EAEdG,EAASnC,KAAK,CAACkB,KAAM,OAAQ3B,MAAOyC,IAG/BG,ECgET,SAASK,EAAclC,GACrB,MAAMmC,EAASnC,EAAKmC,OAEpB,YAAkBC,IAAXD,GAAmC,OAAXA,EAC3BnC,EAAKmB,SAAS7B,OAAS,EACvB6C,EClGC,MAAME,EAAaC,EAAM,SAUnBC,EAAWD,EAAM,OAsB9B,SAASA,EAAM1B,GACb,OAQA,SAAeZ,GACb,MAAMsC,EAAStC,GAAQA,EAAKwC,UAAYxC,EAAKwC,SAAS5B,IAAU,GAGhE,MAAO,CAEL6B,KAAMH,EAAMG,MAAQ,KAEpBC,OAAQJ,EAAMI,QAAU,KAExBC,OAAQL,EAAMK,QAAU,EAAIL,EAAMK,OAAS,O,eCpD1C,MAAMC,EAAW,CACtBC,WCbK,SAAoB9C,EAAOC,GAEhC,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,aACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAK/C,EAAM+B,IAAI9B,IAAO,IAGxC,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IDK7B6D,MEbK,SAAmBhD,EAAOC,GAE/B,MAAMd,EAAS,CAAC0B,KAAM,UAAWC,QAAS,KAAMC,WAAY,GAAIK,SAAU,IAE1E,OADApB,EAAMqB,MAAMpB,EAAMd,GACX,CAACa,EAAMuB,UAAUtB,EAAMd,GAAS,CAAC0B,KAAM,OAAQ3B,MAAO,QFU7Dd,KGbK,SAAc4B,EAAOC,GAC1B,MAAMf,EAAQe,EAAKf,MAAQe,EAAKf,MAAQ,KAAO,GAGzC+D,EAAOhD,EAAKgD,KAAOhD,EAAKgD,KAAKC,MAAM,uBAAyB,KAE5DnC,EAAa,GAEfkC,IACFlC,EAAWoC,UAAY,CAAC,YAAcF,IAKxC,IAAI9D,EAAS,CACX0B,KAAM,UACNC,QAAS,OACTC,aACAK,SAAU,CAAC,CAACP,KAAM,OAAQ3B,WAa5B,OAVIe,EAAKmD,OACPjE,EAAOkE,KAAO,CAACD,KAAMnD,EAAKmD,OAG5BpD,EAAMqB,MAAMpB,EAAMd,GAClBA,EAASa,EAAMuB,UAAUtB,EAAMd,GAG/BA,EAAS,CAAC0B,KAAM,UAAWC,QAAS,MAAOC,WAAY,GAAIK,SAAU,CAACjC,IACtEa,EAAMqB,MAAMpB,EAAMd,GACXA,GHjBPmE,OIfK,SAAuBtD,EAAOC,GAEnC,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,MACTC,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IJO7BoE,SKjBK,SAAkBvD,EAAOC,GAE9B,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,KACTC,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,ILS7BY,kBAAiB,EACjByD,SMXK,SAAkBxD,EAAOC,GAC9B,MAAMwD,EAAezD,EAAMyD,aAC3B,IAAIC,EAAK,EAET,KAAOA,KAAMD,GAAcC,IAE3B,MAAMvD,EAAapB,OAAO2E,GAS1B,OAPAD,EAAatD,GAAc,CACzBU,KAAM,qBACNV,aACAiB,SAAU,CAAC,CAACP,KAAM,YAAaO,SAAUnB,EAAKmB,WAC9CqB,SAAUxC,EAAKwC,UAGV1C,EAAkBC,EAAO,CAC9Ba,KAAM,oBACNV,aACAsC,SAAUxC,EAAKwC,YNNjBkB,QOpBK,SAAiB3D,EAAOC,GAE7B,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,IAAMb,EAAK2D,MACpB7C,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IPY7B0E,KQnBK,SAAc7D,EAAOC,GAC1B,GAAID,EAAM8D,UAAW,CAEnB,MAAM3E,EAAS,CAAC0B,KAAM,MAAO3B,MAAOe,EAAKf,OAEzC,OADAc,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,GAI/B,OAAO,MRWP4E,eSjBK,SAAwB/D,EAAOC,GACpC,MAAM+D,EAAMhE,EAAMiE,WAAWhE,EAAKE,YAElC,IAAK6D,EACH,OAAOxC,EAAOxB,EAAOC,GAIvB,MAAMc,EAAa,CAACmD,IAAKjF,EAAa+E,EAAIG,KAAO,IAAKtC,IAAK5B,EAAK4B,KAE9C,OAAdmC,EAAII,YAAgC/B,IAAd2B,EAAII,QAC5BrD,EAAWqD,MAAQJ,EAAII,OAIzB,MAAMjF,EAAS,CAAC0B,KAAM,UAAWC,QAAS,MAAOC,aAAYK,SAAU,IAEvE,OADApB,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,ITC7BkF,MUpBK,SAAerE,EAAOC,GAE3B,MAAMc,EAAa,CAACmD,IAAKjF,EAAagB,EAAKkE,MAE1B,OAAblE,EAAK4B,UAA6BQ,IAAbpC,EAAK4B,MAC5Bd,EAAWc,IAAM5B,EAAK4B,KAGL,OAAf5B,EAAKmE,YAAiC/B,IAAfpC,EAAKmE,QAC9BrD,EAAWqD,MAAQnE,EAAKmE,OAI1B,MAAMjF,EAAS,CAAC0B,KAAM,UAAWC,QAAS,MAAOC,aAAYK,SAAU,IAEvE,OADApB,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IVM7BmF,WWvBK,SAAoBtE,EAAOC,GAEhC,MAAMsE,EAAO,CAAC1D,KAAM,OAAQ3B,MAAOe,EAAKf,MAAMO,QAAQ,YAAa,MACnEO,EAAMqB,MAAMpB,EAAMsE,GAGlB,MAAMpF,EAAS,CACb0B,KAAM,UACNC,QAAS,OACTC,WAAY,GACZK,SAAU,CAACmD,IAGb,OADAvE,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IXW7BqF,cYpBK,SAAuBxE,EAAOC,GACnC,MAAM+D,EAAMhE,EAAMiE,WAAWhE,EAAKE,YAElC,IAAK6D,EACH,OAAOxC,EAAOxB,EAAOC,GAIvB,MAAMc,EAAa,CAACC,KAAM/B,EAAa+E,EAAIG,KAAO,KAEhC,OAAdH,EAAII,YAAgC/B,IAAd2B,EAAII,QAC5BrD,EAAWqD,MAAQJ,EAAII,OAIzB,MAAMjF,EAAS,CACb0B,KAAM,UACNC,QAAS,IACTC,aACAK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IZD7ByB,KavBK,SAAcZ,EAAOC,GAE1B,MAAMc,EAAa,CAACC,KAAM/B,EAAagB,EAAKkE,MAEzB,OAAflE,EAAKmE,YAAiC/B,IAAfpC,EAAKmE,QAC9BrD,EAAWqD,MAAQnE,EAAKmE,OAI1B,MAAMjF,EAAS,CACb0B,KAAM,UACNC,QAAS,IACTC,aACAK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IbQ7BsF,SFfK,SAAkBzE,EAAOC,EAAMyE,GACpC,MAAMC,EAAU3E,EAAM+B,IAAI9B,GACpB2E,EAAQF,EAyEhB,SAAmBzE,GACjB,IAAI2E,GAAQ,EACZ,GAAkB,SAAd3E,EAAKY,KAAiB,CACxB+D,EAAQ3E,EAAKmC,SAAU,EACvB,MAAMhB,EAAWnB,EAAKmB,SACtB,IAAIhC,GAAS,EAEb,MAAQwF,KAAWxF,EAAQgC,EAAS7B,QAClCqF,EAAQzC,EAAcf,EAAShC,IAInC,OAAOwF,EArFgBC,CAAUH,GAAUvC,EAAclC,GAEnDc,EAAa,GAEbK,EAAW,GAEjB,GAA4B,mBAAjBnB,EAAK6E,QAAuB,CACrC,MAAM9C,EAAO2C,EAAQ,GAErB,IAAII,EAEA/C,GAAsB,YAAdA,EAAKnB,MAAuC,MAAjBmB,EAAKlB,QAC1CiE,EAAY/C,GAEZ+C,EAAY,CAAClE,KAAM,UAAWC,QAAS,IAAKC,WAAY,GAAIK,SAAU,IACtEuD,EAAQ1C,QAAQ8C,IAGdA,EAAU3D,SAAS7B,OAAS,GAC9BwF,EAAU3D,SAASa,QAAQ,CAACpB,KAAM,OAAQ3B,MAAO,MAGnD6F,EAAU3D,SAASa,QAAQ,CACzBpB,KAAM,UACNC,QAAS,QACTC,WAAY,CAACF,KAAM,WAAYiE,QAAS7E,EAAK6E,QAASE,UAAU,GAChE5D,SAAU,KAKZL,EAAWoC,UAAY,CAAC,kBAG1B,IAAI/D,GAAS,EAEb,OAASA,EAAQuF,EAAQpF,QAAQ,CAC/B,MAAM0F,EAAQN,EAAQvF,IAIpBwF,GACU,IAAVxF,GACe,YAAf6F,EAAMpE,MACY,MAAlBoE,EAAMnE,UAENM,EAASzB,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,OAGnB,YAAf+F,EAAMpE,MAAwC,MAAlBoE,EAAMnE,SAAoB8D,EAGxDxD,EAASzB,KAAKsF,GAFd7D,EAASzB,QAAQsF,EAAM7D,UAM3B,MAAMc,EAAOyC,EAAQA,EAAQpF,OAAS,GAGlC2C,IAAS0C,GAAuB,YAAd1C,EAAKrB,MAAuC,MAAjBqB,EAAKpB,UACpDM,EAASzB,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,OAItC,MAAMC,EAAS,CAAC0B,KAAM,UAAWC,QAAS,KAAMC,aAAYK,YAE5D,OADApB,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IEpD7B+F,Kc3BK,SAAclF,EAAOC,GAE1B,MAAMc,EAAa,GACb4D,EAAU3E,EAAM+B,IAAI9B,GAC1B,IAAIb,GAAS,EAOb,IAL0B,kBAAfa,EAAKZ,OAAqC,IAAfY,EAAKZ,QACzC0B,EAAW1B,MAAQY,EAAKZ,SAIjBD,EAAQuF,EAAQpF,QAAQ,CAC/B,MAAM0F,EAAQN,EAAQvF,GAEtB,GACiB,YAAf6F,EAAMpE,MACY,OAAlBoE,EAAMnE,SACNmE,EAAMlE,YACNoE,MAAMC,QAAQH,EAAMlE,WAAWoC,YAC/B8B,EAAMlE,WAAWoC,UAAUkC,SAAS,kBACpC,CACAtE,EAAWoC,UAAY,CAAC,sBACxB,OAKJ,MAAMhE,EAAS,CACb0B,KAAM,UACNC,QAASb,EAAKqF,QAAU,KAAO,KAC/BvE,aACAK,SAAUpB,EAAM+C,KAAK4B,GAAS,IAGhC,OADA3E,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IdN7B4F,Ue7BK,SAAmB/E,EAAOC,GAE/B,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,IACTC,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IfqB7BoG,KgB7BK,SAAcvF,EAAOC,GAE1B,MAAMd,EAAS,CAAC0B,KAAM,OAAQO,SAAUpB,EAAM+C,KAAK/C,EAAM+B,IAAI9B,KAE7D,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IhB0B7BqG,OiB/BK,SAAgBxF,EAAOC,GAE5B,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,SACTC,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IjBuB7BsG,MkB9BK,SAAezF,EAAOC,GAC3B,MAAMyF,EAAO1F,EAAM+B,IAAI9B,GACjB0F,EAAWD,EAAKE,QAEhBC,EAAe,GAErB,GAAIF,EAAU,CAEZ,MAAM3D,EAAO,CACXnB,KAAM,UACNC,QAAS,QACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAK,CAAC4C,IAAW,IAEnC3F,EAAMqB,MAAMpB,EAAKmB,SAAS,GAAIY,GAC9B6D,EAAalG,KAAKqC,GAGpB,GAAI0D,EAAKnG,OAAS,EAAG,CAEnB,MAAMuG,EAAO,CACXjF,KAAM,UACNC,QAAS,QACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAK2C,GAAM,IAGvBrG,EAAQiD,EAAWrC,EAAKmB,SAAS,IACjC2E,EAAMvD,EAASvC,EAAKmB,SAASnB,EAAKmB,SAAS7B,OAAS,IACtDF,EAAMqD,MAAQqD,EAAIrD,OAAMoD,EAAKrD,SAAW,CAACpD,QAAO0G,QACpDF,EAAalG,KAAKmG,GAIpB,MAAM3G,EAAS,CACb0B,KAAM,UACNC,QAAS,QACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAK8C,GAAc,IAGrC,OADA7F,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IlBV7B6G,UmBjCK,SAAmBhG,EAAOC,GAI/B,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,KACTC,WAAY,GACZK,SAAUpB,EAAM+B,IAAI9B,IAGtB,OADAD,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,InBuB7B8G,SoBtBK,SAAkBjG,EAAOC,EAAMyE,GACpC,MAAMwB,EAAWxB,EAASA,EAAOtD,cAAWiB,EAGtCvB,EAAuB,KADZoF,EAAWA,EAAS1F,QAAQP,GAAQ,GACpB,KAAO,KAClCkG,EAAQzB,GAA0B,UAAhBA,EAAO7D,KAAmB6D,EAAOyB,WAAQ9D,EAC3D9C,EAAS4G,EAAQA,EAAM5G,OAASU,EAAKmB,SAAS7B,OACpD,IAAI6G,GAAa,EAEjB,MAAMC,EAAQ,GAEd,OAASD,EAAY7G,GAAQ,CAE3B,MAAM+G,EAAOrG,EAAKmB,SAASgF,GAErBrF,EAAa,GACbwF,EAAaJ,EAAQA,EAAMC,QAAa/D,EAE1CkE,IACFxF,EAAWoF,MAAQI,GAIrB,IAAIpH,EAAS,CAAC0B,KAAM,UAAWC,UAASC,aAAYK,SAAU,IAE1DkF,IACFnH,EAAOiC,SAAWpB,EAAM+B,IAAIuE,GAC5BtG,EAAMqB,MAAMiF,EAAMnH,GAClBA,EAASa,EAAMuB,UAAUtB,EAAMd,IAGjCkH,EAAM1G,KAAKR,GAIb,MAAMA,EAAS,CACb0B,KAAM,UACNC,QAAS,KACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAKsD,GAAO,IAG9B,OADArG,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IpBnB7BoF,KqBhCK,SAAcvE,EAAOC,GAE1B,MAAMd,EAAS,CAAC0B,KAAM,OAAQ3B,OAAOsH,EAAAA,EAAAA,GAAUzH,OAAOkB,EAAKf,SAE3D,OADAc,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,IrB6B7BsH,csBpCK,SAAuBzG,EAAOC,GAEnC,MAAMd,EAAS,CACb0B,KAAM,UACNC,QAAS,KACTC,WAAY,GACZK,SAAU,IAGZ,OADApB,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,ItB4B7BuH,KAAMC,EACNC,KAAMD,EACN1C,WAAY0C,EACZE,mBAAoBF,GAItB,SAASA,IAEP,OAAO,K,cuB8BF,MAyEMG,EAYT,SAAUhI,GACR,QAAauD,IAATvD,GAA+B,OAATA,EACxB,OAAOiI,EAGT,GAAoB,kBAATjI,EACT,OA8ER,SAAqBkI,GACnB,OAAOC,EAAYpG,GAKnB,SAASA,EAAKZ,GACZ,OAAOA,GAAQA,EAAKY,OAASmG,GArFlBE,CAAYpI,GAGrB,GAAoB,kBAATA,EACT,OAAOqG,MAAMC,QAAQtG,GAe7B,SAAoBqI,GAElB,MAAMC,EAAS,GACf,IAAIhI,GAAS,EAEb,OAASA,EAAQ+H,EAAM5H,QACrB6H,EAAOhI,GAAS0H,EAAQK,EAAM/H,IAGhC,OAAO6H,EAAYI,GAOnB,SAASA,IACP,IAAIjI,GAAS,EAAC,QAAAkI,EAAAC,UAAAhI,OADAiI,EAAU,IAAArC,MAAAmC,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAVD,EAAUC,GAAAF,UAAAE,GAGxB,OAASrI,EAAQgI,EAAO7H,QACtB,GAAI6H,EAAOhI,GAAOsI,KAAKC,QAASH,GAAa,OAAO,EAGtD,OAAO,GAtC0BI,CAAW9I,GAgDhD,SAAsBkI,GACpB,OAAOC,EAAYlF,GAMnB,SAASA,EAAI9B,GAEX,IAAI4H,EAEJ,IAAKA,KAAOb,EAEV,GAAI/G,EAAK4H,KAASb,EAAMa,GAAM,OAAO,EAGvC,OAAO,GAhE6CC,CAAahJ,GAG/D,GAAoB,oBAATA,EACT,OAAOmI,EAAYnI,GAGrB,MAAM,IAAIiJ,MAAM,iDAoFtB,SAASd,EAAYD,GACnB,OAQA,SAAmB/G,GAAqB,QAAA+H,EAAAT,UAAAhI,OAAZiI,EAAU,IAAArC,MAAA6C,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAVT,EAAUS,EAAA,GAAAV,UAAAU,GACpC,OAAOC,QACLjI,GACkB,kBAATA,GACP,SAAUA,GAEViI,QAAQlB,EAAMU,KAAKC,KAAM1H,KAASuH,MAK1C,SAAST,IACP,OAAO,EC3NF,MAyCMoB,EAeT,SAAUC,EAAMtJ,EAAMuJ,EAASC,GACT,oBAATxJ,GAA0C,oBAAZuJ,IACvCC,EAAUD,EAEVA,EAAUvJ,EACVA,EAAO,MAGT,MAAMyJ,EAAKzB,EAAQhI,GACb0J,EAAOF,GAAW,EAAI,GAS5B,SAASG,EAAQxI,EAAMb,EAAOsJ,GAG5B,MAAMxJ,EAAQe,GAAwB,kBAATA,EAAoBA,EAAO,GAExD,GAA0B,kBAAff,EAAM2B,KAAmB,CAClC,MAAM8H,EAEqB,kBAAlBzJ,EAAM4B,QACT5B,EAAM4B,QAEc,kBAAf5B,EAAMyJ,KACXzJ,EAAMyJ,UACNtG,EAENuG,OAAOC,eAAeC,EAAO,OAAQ,CACnC5J,MACE,SAAiBe,EAAKY,MAAQ8H,EAAO,IAAMA,EAAO,IAAM,IAAO,MAIrE,OAAOG,EAEP,SAASA,IAEP,IAEIC,EAEAnG,EAEAoG,EANA7J,EAAS,GAQb,KAAKL,GAAQyJ,EAAGtI,EAAMb,EAAOsJ,EAAQA,EAAQnJ,OAAS,IAAM,SAC1DJ,EA0CZ,SAAkBD,GAChB,GAAIiG,MAAMC,QAAQlG,GAChB,OAAOA,EAGT,GAAqB,kBAAVA,EACT,MAAO,CA5Ja,KA4JFA,GAGpB,MAAO,CAACA,GAnDW+J,CAASZ,EAAQpI,EAAMyI,IAvGxB,QAyGJvJ,EAAO,IACT,OAAOA,EAKX,GAAIc,EAAKmB,UA1GC,SA0GWjC,EAAO,GAO1B,IALAyD,GAAU0F,EAAUrI,EAAKmB,SAAS7B,QAAU,GAAKiJ,EAEjDQ,EAAeN,EAAQQ,OAAOjJ,GAGvB2C,GAAU,GAAKA,EAAS3C,EAAKmB,SAAS7B,QAAQ,CAInD,GAFAwJ,EAAYN,EAAQxI,EAAKmB,SAASwB,GAASA,EAAQoG,EAAvCP,GAxHN,QA0HFM,EAAU,GACZ,OAAOA,EAGTnG,EAC0B,kBAAjBmG,EAAU,GAAkBA,EAAU,GAAKnG,EAAS4F,EAIjE,OAAOrJ,GArEXsJ,CAAQL,OAAM/F,EAAW,GAAzBoG,ICLC,MC3HDU,EAAM,GAAGC,eAaR,SAASC,EAAYjB,GAE1B,MAAMkB,EAAQV,OAAOW,OAAO,MAE5B,IAAKnB,IAASA,EAAKvH,KACjB,MAAM,IAAIkH,MAAM,wCAUlB,OD8GE,SAAUK,EAAMtJ,EAAMuJ,EAASC,GACT,oBAATxJ,GAA0C,oBAAZuJ,IACvCC,EAAUD,EACVA,EAAUvJ,EACVA,EAAO,MAGTqJ,EAAaC,EAAMtJ,GAMnB,SAAkBmB,EAAMyI,GACtB,MAAMhE,EAASgE,EAAQA,EAAQnJ,OAAS,GACxC,OAAO8I,EACLpI,EACAyE,EAASA,EAAOtD,SAASZ,QAAQP,GAAQ,KACzCyE,KAX+B4D,GC5HvCQ,CAAMV,EAAM,cAAenE,IACzB,MAAM/D,EAAKsJ,EAAMvF,EAAW9D,YACxBD,IAAOiJ,EAAIzB,KAAK4B,EAAOpJ,KACzBoJ,EAAMpJ,GAAM+D,MAOhB,SAAoB9D,GAClB,MAAMD,EAAKsJ,EAAMrJ,GAEjB,OAAOD,GAAMiJ,EAAIzB,KAAK4B,EAAOpJ,GAAMoJ,EAAMpJ,GAAM,MAQnD,SAASsJ,EAAMtK,GACb,OAAOH,OAAOG,GAAS,IAAIkB,cCyG7B,MAAM+I,EAAM,GAAGC,eA6Lf,SAAS/H,EAAMoI,EAAMC,G5BnTd,IAAkBzJ,E4BoTnBwJ,EAAKhH,WAAUiH,EAAGjH,S5BnTf,CAACpD,MAAOiD,EADQrC,E4BoTmBwJ,G5BnTT1D,IAAKvD,EAASvC,K4BkUjD,SAASsB,EAAUkI,EAAMC,GAEvB,IAAIvK,EAASuK,EAGb,GAAID,GAAQA,EAAKpG,KAAM,CACrB,MAAMsG,EAAQF,EAAKpG,KAAKsG,MAClBC,EAAYH,EAAKpG,KAAKuG,UACtBC,EAAcJ,EAAKpG,KAAKwG,YAET,kBAAVF,IAGW,YAAhBxK,EAAO0B,KACT1B,EAAO2B,QAAU6I,EAOjBxK,EAAS,CACP0B,KAAM,UACNC,QAAS6I,EACT5I,WAAY,GACZK,SAAU,KAeI,YAAhBjC,EAAO0B,MAAsBgJ,IAC/B1K,EAAO4B,WAAa,IAAI5B,EAAO4B,cAAe8I,IAI9C,aAAc1K,GACdA,EAAOiC,UACO,OAAdwI,QACcvH,IAAduH,IAGAzK,EAAOiC,SAAWwI,GAItB,OAAOzK,EAgBF,SAAS2K,EAAI9J,EAAOC,EAAMyE,GAC/B,MAAM7D,EAAOZ,GAAQA,EAAKY,KAG1B,IAAKA,EACH,MAAM,IAAIkH,MAAM,uBAAyB9H,EAAO,KAGlD,OAAIkJ,EAAIzB,KAAK1H,EAAM6C,SAAUhC,GACpBb,EAAM6C,SAAShC,GAAMb,EAAOC,EAAMyE,GAGvC1E,EAAM+J,aAAe/J,EAAM+J,YAAY1E,SAASxE,GAG3C,aAAcZ,EAAO,IAAIA,EAAMmB,SAAUW,EAAI/B,EAAOC,IAASA,EAGlED,EAAMgK,eACDhK,EAAMgK,eAAehK,EAAOC,EAAMyE,GAiE7C,SAA+B1E,EAAOC,GACpC,MAAMoD,EAAOpD,EAAKoD,MAAQ,GAEpBlE,IACJ,UAAWc,IACTkJ,EAAIzB,KAAKrE,EAAM,gBAAkB8F,EAAIzB,KAAKrE,EAAM,aAE9C,CACExC,KAAM,UACNC,QAAS,MACTC,WAAY,GACZK,SAAUW,EAAI/B,EAAOC,IALvB,CAACY,KAAM,OAAQ3B,MAAOe,EAAKf,OASjC,OADAc,EAAMqB,MAAMpB,EAAMd,GACXa,EAAMuB,UAAUtB,EAAMd,GA7EtB8K,CAAsBjK,EAAOC,GAc/B,SAAS8B,EAAI/B,EAAO0E,GAEzB,MAAMwF,EAAS,GAEf,GAAI,aAAcxF,EAAQ,CACxB,MAAMyF,EAAQzF,EAAOtD,SACrB,IAAIhC,GAAS,EACb,OAASA,EAAQ+K,EAAM5K,QAAQ,CAC7B,MAAMJ,EAAS2K,EAAI9J,EAAOmK,EAAM/K,GAAQsF,GAGxC,GAAIvF,EAAQ,CACV,GAAIC,GAAmC,UAA1B+K,EAAM/K,EAAQ,GAAGyB,OACvBsE,MAAMC,QAAQjG,IAA2B,SAAhBA,EAAO0B,OACnC1B,EAAOD,MAAQC,EAAOD,MAAMO,QAAQ,OAAQ,MAGzC0F,MAAMC,QAAQjG,IAA2B,YAAhBA,EAAO0B,MAAoB,CACvD,MAAMmB,EAAO7C,EAAOiC,SAAS,GAEzBY,GAAsB,SAAdA,EAAKnB,OACfmB,EAAK9C,MAAQ8C,EAAK9C,MAAMO,QAAQ,OAAQ,KAK1C0F,MAAMC,QAAQjG,GAChB+K,EAAOvK,QAAQR,GAEf+K,EAAOvK,KAAKR,KAMpB,OAAO+K,EA2CF,SAASnH,EAAKoH,EAAOvF,GAE1B,MAAMzF,EAAS,GACf,IAAIC,GAAS,EAMb,IAJIwF,GACFzF,EAAOQ,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,SAG3BE,EAAQ+K,EAAM5K,QACjBH,GAAOD,EAAOQ,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,OAC7CC,EAAOQ,KAAKwK,EAAM/K,IAOpB,OAJIwF,GAASuF,EAAM5K,OAAS,GAC1BJ,EAAOQ,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,OAG7BC,EC/dF,SAASiL,EAAOhC,EAAMiC,GAC3B,MAAMrK,EDkFD,SAAqBoI,EAAMiC,GAChC,MAAMC,EAAWD,GAAW,GACtBvG,EAAYwG,EAASC,qBAAsB,EAE3C9G,EAAe,GA2DrB,OAnDAzD,EAAM8D,UAAYA,EAElB9D,EAAMiB,mBACuBoB,IAA3BiI,EAASrJ,eAA0D,OAA3BqJ,EAASrJ,cAC7C,gBACAqJ,EAASrJ,cAEfjB,EAAMwK,cAAgBF,EAASE,eAAiB,YAEhDxK,EAAMyK,qBAAuBH,EAASG,sBAAwB,KAE9DzK,EAAM0K,wBAA0BJ,EAASI,yBAA2B,CAClEvH,UAAW,CAAC,YAGdnD,EAAM2K,kBAAoBL,EAASK,mBAAqB,kBAExD3K,EAAMgK,eAAiBM,EAASN,eAEhChK,EAAM+J,YAAcO,EAASP,YAE7B/J,EAAM6C,SAAW,IAAIA,KAAayH,EAASzH,UAI3C7C,EAAMiE,WAAaoF,EAAYjB,GAC/BpI,EAAMyD,aAAeA,EAErBzD,EAAMO,cAAgB,GAEtBP,EAAMU,eAAiB,GAEvBV,EAAMqB,MAAQA,EACdrB,EAAMuB,UAAYA,EAClBvB,EAAM8J,IAsGN,SAAkB7J,EAAMyE,GAEtB,OAAOoF,EAAI9J,EAAOC,EAAMyE,IAvG1B1E,EAAM+B,IAkHN,SAAkB2C,GAEhB,OAAO3C,EAAI/B,EAAO0E,IAnHpB1E,EAAM+C,KAAOA,EAEb/C,EAAM4K,QAAUA,GAEhB9B,EAAAA,EAAAA,IAAMV,EAAM,sBAAuBnE,IACjC,MAAM/D,EAAKnB,OAAOkF,EAAW9D,YAAYC,cAIpC+I,EAAIzB,KAAKjE,EAAcvD,KAC1BuD,EAAavD,GAAM+D,MAKhBjE,EAWP,SAAS4K,EAAQC,EAAMC,GAErB,GAAID,GAAQ,SAAUA,GAAQA,EAAKxH,KAAM,CAEvC,MAAMA,EAAOwH,EAAKxH,KAEdA,EAAKsG,QACY,YAAfmB,EAAMjK,OACRiK,EAAQ,CACNjK,KAAM,UACNC,QAAS,GACTC,WAAY,GACZK,SAAU,KAId0J,EAAMhK,QAAUuC,EAAKsG,OAGJ,YAAfmB,EAAMjK,MAAsBwC,EAAKwG,cACnCiB,EAAM/J,WAAa,IAAI+J,EAAM/J,cAAesC,EAAKwG,cAG/C,aAAciB,GAASA,EAAM1J,UAAYiC,EAAKuG,YAChDkB,EAAM1J,SAAWiC,EAAKuG,WAI1B,GAAIiB,EAAM,CACR,MAAME,EAAM,SAAUF,EAAOA,EAAO,CAACpI,SAAUoI,IEpQ3B5K,EFsQL8K,IEnQhB9K,EAAKwC,UACLxC,EAAKwC,SAASpD,OACdY,EAAKwC,SAASpD,MAAMqD,MACpBzC,EAAKwC,SAASpD,MAAMsD,QACpB1C,EAAKwC,SAASsD,KACd9F,EAAKwC,SAASsD,IAAIrD,MAClBzC,EAAKwC,SAASsD,IAAIpD,SF+PfmI,EAAMrI,SAAW,CAACpD,MAAOiD,EAAWyI,GAAMhF,IAAKvD,EAASuI,KExQzD,IAAmB9K,EF4QtB,OAAO6K,EAWT,SAAS9K,EAAMC,EAAMa,EAASkK,EAAO5J,GAOnC,OANI+D,MAAMC,QAAQ4F,KAChB5J,EAAW4J,EACXA,EAAQ,IAIHJ,EAAQ3K,EAAM,CACnBY,KAAM,UACNC,UACAC,WAAYiK,GAAS,GACrB5J,SAAUA,GAAY,MCvNZ6J,CAAY7C,EAAMiC,GAC1BpK,EAAOD,EAAM8J,IAAI1B,EAAM,MACvB8C,EElFD,SAAgBlL,GAErB,MAAMmL,EAAY,GAClB,IAAI/L,GAAS,EAEb,OAASA,EAAQY,EAAMO,cAAchB,QAAQ,CAC3C,MAAMyE,EAAMhE,EAAMyD,aAAazD,EAAMO,cAAcnB,IAEnD,IAAK4E,EACH,SAGF,MAAMoH,EAAUpL,EAAM+B,IAAIiC,GACpB9D,EAAKnB,OAAOiF,EAAI7D,YAAYC,cAC5BC,EAASpB,EAAaiB,EAAGI,eAC/B,IAAI+K,EAAiB,EAErB,MAAMC,EAAiB,GAEvB,OAASD,GAAkBrL,EAAMU,eAAeR,IAAK,CAEnD,MAAMqL,EAAgB,CACpB1K,KAAM,UACNC,QAAS,IACTC,WAAY,CACVC,KACE,IACAhB,EAAMiB,cACN,SACAZ,GACCgL,EAAiB,EAAI,IAAMA,EAAiB,IAC/CG,qBAAqB,EACrBrI,UAAW,CAAC,yBACZsI,UAAWzL,EAAM2K,mBAEnBvJ,SAAU,CAAC,CAACP,KAAM,OAAQ3B,MAAO,YAG/BmM,EAAiB,GACnBE,EAAcnK,SAASzB,KAAK,CAC1BkB,KAAM,UACNC,QAAS,MACTM,SAAU,CAAC,CAACP,KAAM,OAAQ3B,MAAOH,OAAOsM,OAIxCC,EAAe/L,OAAS,GAC1B+L,EAAe3L,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,MAG5CoM,EAAe3L,KAAK4L,GAGtB,MAAMrJ,EAAOkJ,EAAQA,EAAQ7L,OAAS,GAEtC,GAAI2C,GAAsB,YAAdA,EAAKrB,MAAuC,MAAjBqB,EAAKpB,QAAiB,CAC3D,MAAM4K,EAAWxJ,EAAKd,SAASc,EAAKd,SAAS7B,OAAS,GAClDmM,GAA8B,SAAlBA,EAAS7K,KACvB6K,EAASxM,OAAS,IAElBgD,EAAKd,SAASzB,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,MAG3CgD,EAAKd,SAASzB,QAAQ2L,QAEtBF,EAAQzL,QAAQ2L,GAIlB,MAAM7G,EAAW,CACf5D,KAAM,UACNC,QAAS,KACTC,WAAY,CAACb,GAAIF,EAAMiB,cAAgB,MAAQZ,GAC/Ce,SAAUpB,EAAM+C,KAAKqI,GAAS,IAGhCpL,EAAMqB,MAAM2C,EAAKS,GAEjB0G,EAAUxL,KAAK8E,GAGjB,GAAyB,IAArB0G,EAAU5L,OAId,MAAO,CACLsB,KAAM,UACNC,QAAS,UACTC,WAAY,CAAC4K,eAAe,EAAMxI,UAAW,CAAC,cAC9C/B,SAAU,CACR,CACEP,KAAM,UACNC,QAASd,EAAMyK,qBACf1J,WAAY,IAEP6K,KAAKC,MAAMD,KAAKE,UAAU9L,EAAM0K,0BACnCxK,GAAI,kBAENkB,SAAU,CAAC,CAACP,KAAM,OAAQ3B,MAAOc,EAAMwK,iBAEzC,CAAC3J,KAAM,OAAQ3B,MAAO,MACtB,CACE2B,KAAM,UACNC,QAAS,KACTC,WAAY,GACZK,SAAUpB,EAAM+C,KAAKoI,GAAW,IAElC,CAACtK,KAAM,OAAQ3B,MAAO,QFzBb6M,CAAO/L,GAUpB,OARIkL,GAIFjL,EAAKmB,SAASzB,KAAK,CAACkB,KAAM,OAAQ3B,MAAO,MAAOgM,GAI3C/F,MAAMC,QAAQnF,GAAQ,CAACY,KAAM,OAAQO,SAAUnB,GAAQA,EG1EhE,MAUA,EAPI,SAAU+L,EAAa3B,GACrB,OAAO2B,GAAe,QAASA,EAcrC,SAAgBA,EAAa3B,GAC3B,MAAO,CAACpK,EAAMgM,EAAMvM,KAClBsM,EAAYE,IAAI9B,EAAOnK,EAAMoK,GAAU4B,GAAOE,IAC5CzM,EAAKyM,OAhBDC,CAAOJ,EAAa3B,GA2B9B,SAAgBA,GAEd,OAAQpK,GAASmK,EAAOnK,EAAMoK,GA5BtBgC,CAAOL,GAAe3B,K,iCCmDzB,MAyEMvD,EAYT,SAAUhI,GACR,QAAauD,IAATvD,GAA+B,OAATA,EACxB,OAAOiI,EAGT,GAAoB,kBAATjI,EACT,OA8ER,SAAqBkI,GACnB,OAAOC,EAAYpG,GAKnB,SAASA,EAAKZ,GACZ,OAAOA,GAAQA,EAAKY,OAASmG,GArFlBE,CAAYpI,GAGrB,GAAoB,kBAATA,EACT,OAAOqG,MAAMC,QAAQtG,GAe7B,SAAoBqI,GAElB,MAAMC,EAAS,GACf,IAAIhI,GAAS,EAEb,OAASA,EAAQ+H,EAAM5H,QACrB6H,EAAOhI,GAAS0H,EAAQK,EAAM/H,IAGhC,OAAO6H,EAAYI,GAOnB,SAASA,IACP,IAAIjI,GAAS,EAAC,QAAAkI,EAAAC,UAAAhI,OADAiI,EAAU,IAAArC,MAAAmC,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAVD,EAAUC,GAAAF,UAAAE,GAGxB,OAASrI,EAAQgI,EAAO7H,QACtB,GAAI6H,EAAOhI,GAAOsI,KAAKC,QAASH,GAAa,OAAO,EAGtD,OAAO,GAtC0BI,CAAW9I,GAgDhD,SAAsBkI,GACpB,OAAOC,EAAYlF,GAMnB,SAASA,EAAI9B,GAEX,IAAI4H,EAEJ,IAAKA,KAAOb,EAEV,GAAI/G,EAAK4H,KAASb,EAAMa,GAAM,OAAO,EAGvC,OAAO,GAhE6CC,CAAahJ,GAG/D,GAAoB,oBAATA,EACT,OAAOmI,EAAYnI,GAGrB,MAAM,IAAIiJ,MAAM,iDAoFtB,SAASd,EAAYD,GACnB,OAQA,SAAmB/G,GAAqB,QAAA+H,EAAAT,UAAAhI,OAAZiI,EAAU,IAAArC,MAAA6C,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAVT,EAAUS,EAAA,GAAAV,UAAAU,GACpC,OAAOC,QACLjI,GACkB,kBAATA,GACP,SAAUA,GAEViI,QAAQlB,EAAMU,KAAKC,KAAM1H,KAASuH,MAK1C,SAAST,IACP,OAAO,I,0DC3NF,MAKMuF,GAAO,EAoCPnE,EAeT,SAAUC,EAAMtJ,EAAMuJ,EAASC,GACT,oBAATxJ,GAA0C,oBAAZuJ,IACvCC,EAAUD,EAEVA,EAAUvJ,EACVA,EAAO,MAGT,MAAMyJ,GAAKzB,EAAAA,EAAAA,GAAQhI,GACb0J,EAAOF,GAAW,EAAI,GAS5B,SAASG,EAAQxI,EAAMb,EAAOsJ,GAG5B,MAAMxJ,EAAQe,GAAwB,kBAATA,EAAoBA,EAAO,GAExD,GAA0B,kBAAff,EAAM2B,KAAmB,CAClC,MAAM8H,EAEqB,kBAAlBzJ,EAAM4B,QACT5B,EAAM4B,QAEc,kBAAf5B,EAAMyJ,KACXzJ,EAAMyJ,UACNtG,EAENuG,OAAOC,eAAeC,EAAO,OAAQ,CACnC5J,MACE,SAAiBe,EAAKY,MAAQ8H,EAAO,IAAMA,EAAO,IAAM,IAAO,MAIrE,OAAOG,EAEP,SAASA,IAEP,IAEIC,EAEAnG,EAEAoG,EANA7J,EAAS,GAQb,KAAKL,GAAQyJ,EAAGtI,EAAMb,EAAOsJ,EAAQA,EAAQnJ,OAAS,IAAM,SAC1DJ,EA0CZ,SAAkBD,GAChB,GAAIiG,MAAMC,QAAQlG,GAChB,OAAOA,EAGT,GAAqB,kBAAVA,EACT,MAAO,CA5Ja,KA4JFA,GAGpB,MAAO,CAACA,GAnDW+J,CAASZ,EAAQpI,EAAMyI,IAE5BvJ,EAAO,KAAOmN,GAChB,OAAOnN,EAKX,GAAIc,EAAKmB,UA1GC,SA0GWjC,EAAO,GAO1B,IALAyD,GAAU0F,EAAUrI,EAAKmB,SAAS7B,QAAU,GAAKiJ,EAEjDQ,EAAeN,EAAQQ,OAAOjJ,GAGvB2C,GAAU,GAAKA,EAAS3C,EAAKmB,SAAS7B,QAAQ,CAInD,GAFAwJ,EAAYN,EAAQxI,EAAKmB,SAASwB,GAASA,EAAQoG,EAAvCP,GAERM,EAAU,KAAOuD,EACnB,OAAOvD,EAGTnG,EAC0B,kBAAjBmG,EAAU,GAAkBA,EAAU,GAAKnG,EAAS4F,EAIjE,OAAOrJ,GArEXsJ,CAAQL,OAAM/F,EAAW,GAAzBoG,K,gDCLC,MAAMK,EAeT,SAAUV,EAAMtJ,EAAMuJ,EAASC,GACT,oBAATxJ,GAA0C,oBAAZuJ,IACvCC,EAAUD,EACVA,EAAUvJ,EACVA,EAAO,OAGTqJ,EAAAA,EAAAA,IAAaC,EAAMtJ,GAMnB,SAAkBmB,EAAMyI,GACtB,MAAMhE,EAASgE,EAAQA,EAAQnJ,OAAS,GACxC,OAAO8I,EACLpI,EACAyE,EAASA,EAAOtD,SAASZ,QAAQP,GAAQ,KACzCyE,KAX+B4D","sources":["../node_modules/@blocknote/core/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/@blocknote/core/node_modules/micromark-util-character/index.js","../node_modules/@blocknote/core/node_modules/micromark-util-sanitize-uri/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/revert.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/list-item.js","../node_modules/@blocknote/core/node_modules/unist-util-position/lib/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/break.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/code.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/delete.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/footnote.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/heading.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/html.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/image.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/link.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/list.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/root.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/strong.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/table.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/table-row.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/text.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","../node_modules/mdast-util-definitions/node_modules/unist-util-is/lib/index.js","../node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-definitions/node_modules/unist-util-visit/lib/index.js","../node_modules/mdast-util-definitions/lib/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/state.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/index.js","../node_modules/unist-util-generated/lib/index.js","../node_modules/@blocknote/core/node_modules/mdast-util-to-hast/lib/footer.js","../node_modules/@blocknote/core/node_modules/remark-rehype/lib/index.js","../node_modules/@blocknote/core/node_modules/unist-util-is/lib/index.js","../node_modules/@blocknote/core/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/@blocknote/core/node_modules/unist-util-visit/lib/index.js"],"sourcesContent":["// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n  if (!protocol) {\n    return value\n  }\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n  if (\n    // If there is no protocol, it’s relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n  return ''\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n    let replace = ''\n\n    // A correct percent encoded value.\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    }\n    // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1)\n\n      // A correct surrogate pair.\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      }\n      // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n  return result.join('') + value.slice(start)\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('hast').Element} Element\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  if (index === -1) {\n    state.footnoteOrder.push(id)\n    state.footnoteCounts[id] = 1\n    counter = state.footnoteOrder.length\n  } else {\n    state.footnoteCounts[id]++\n    counter = index + 1\n  }\n\n  const reuseCounter = state.footnoteCounts[id]\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + state.clobberPrefix + 'fn-' + safeId,\n      id:\n        state.clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return {type: 'text', value: '![' + node.alt + suffix}\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === undefined || spread === null\n    ? node.children.length > 1\n    : spread\n}\n","/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    // To do: next major: don’t return points when invalid.\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {footnote} from './footnote.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  footnote,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  // To do: next major, use `node.lang` w/o regex, the splitting’s been going\n  // on for years in remark now.\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null\n  /** @type {Properties} */\n  const properties = {}\n\n  if (lang) {\n    properties.className = ['language-' + lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Footnote} Footnote\n * @typedef {import('../state.js').State} State\n */\n\nimport {footnoteReference} from './footnote-reference.js'\n\n// To do: when both:\n// * <https://github.com/micromark/micromark-extension-footnote>\n// * <https://github.com/syntax-tree/mdast-util-footnote>\n// …are archived, remove this (also from mdast).\n// These inline notes are not used in GFM.\n\n/**\n * Turn an mdast `footnote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Footnote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnote(state, node) {\n  const footnoteById = state.footnoteById\n  let no = 1\n\n  while (no in footnoteById) no++\n\n  const identifier = String(no)\n\n  footnoteById[identifier] = {\n    type: 'footnoteDefinition',\n    identifier,\n    children: [{type: 'paragraph', children: node.children}],\n    position: node.position\n  }\n\n  return footnoteReference(state, {\n    type: 'footnoteReference',\n    identifier,\n    position: node.position\n  })\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').HTML} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Raw | Element | null}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.dangerous) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(def.url || ''), alt: node.alt}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(def.url || '')}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastRoot | HastElement}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointStart, pointEnd} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start.line && end.line) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastText | HastElement}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\n\nimport {visit} from 'unist-util-visit'\nimport {position, pointStart, pointEnd} from 'unist-util-position'\nimport {generated} from 'unist-util-generated'\nimport {definitions} from 'mdast-util-definitions'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || {}\n  const dangerous = settings.allowDangerousHtml || false\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n  const footnoteById = {}\n\n  // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n  state.dangerous = dangerous\n  // To do: next major: move to `state.options`.\n  state.clobberPrefix =\n    settings.clobberPrefix === undefined || settings.clobberPrefix === null\n      ? 'user-content-'\n      : settings.clobberPrefix\n  // To do: next major: move to `state.options`.\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  // To do: next major: move to `state.options`.\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'\n  // To do: next major: move to `state.options`.\n  state.unknownHandler = settings.unknownHandler\n  // To do: next major: move to `state.options`.\n  state.passThrough = settings.passThrough\n\n  state.handlers = {...handlers, ...settings.handlers}\n\n  // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n  state.definition = definitions(tree)\n  state.footnoteById = footnoteById\n  /** @type {Array<string>} */\n  state.footnoteOrder = []\n  /** @type {Record<string, number>} */\n  state.footnoteCounts = {}\n\n  state.patch = patch\n  state.applyData = applyData\n  state.one = oneBound\n  state.all = allBound\n  state.wrap = wrap\n  // To do: next major: remove `augment`.\n  state.augment = augment\n\n  visit(tree, 'footnoteDefinition', (definition) => {\n    const id = String(definition.identifier).toUpperCase()\n\n    // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition\n    }\n  })\n\n  // @ts-expect-error Hush, it’s fine!\n  return state\n\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          }\n        }\n\n        right.tagName = data.hName\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = {...right.properties, ...data.hProperties}\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {position: left}\n\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {start: pointStart(ctx), end: pointEnd(ctx)}\n      }\n    }\n\n    return right\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props\n      props = {}\n    }\n\n    // @ts-expect-error augmenting an element yields an element.\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    })\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n  function oneBound(node, parent) {\n    // @ts-expect-error: that’s a state :)\n    return one(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function allBound(parent) {\n    // @ts-expect-error: that’s a state :)\n    return all(state, parent)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        }\n\n        // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = {...result.properties, ...hProperties}\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\nexport function one(state, node, parent) {\n  const type = node && node.type\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent)\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? {...node, children: all(state, node)} : node\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent)\n  }\n\n  return defaultUnknownHandler(state, node)\n}\n\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent)\n\n      // To do: see if we van clean this? Can we merge texts?\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastText | HastElement} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: all(state, node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */\n\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HastNodes | null | undefined}\n *   hast tree.\n */\n// To do: next major: always return a single `root`.\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, null)\n  const foot = footer(state)\n\n  if (foot) {\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  // To do: next major: always return root?\n  return Array.isArray(node) ? {type: 'root', children: node} : node\n}\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\nexport function footer(state) {\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let index = -1\n\n  while (++index < state.footnoteOrder.length) {\n    const def = state.footnoteById[state.footnoteOrder[index]]\n\n    if (!def) {\n      continue\n    }\n\n    const content = state.all(def)\n    const id = String(def.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let referenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n\n    while (++referenceIndex <= state.footnoteCounts[id]) {\n      /** @type {Element} */\n      const backReference = {\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            state.clobberPrefix +\n            'fnref-' +\n            safeId +\n            (referenceIndex > 1 ? '-' + referenceIndex : ''),\n          dataFootnoteBackref: true,\n          className: ['data-footnote-backref'],\n          ariaLabel: state.footnoteBackLabel\n        },\n        children: [{type: 'text', value: '↩'}]\n      }\n\n      if (referenceIndex > 1) {\n        backReference.children.push({\n          type: 'element',\n          tagName: 'sup',\n          children: [{type: 'text', value: String(referenceIndex)}]\n        })\n      }\n\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      backReferences.push(backReference)\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: state.clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(def, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: state.footnoteLabelTagName,\n        properties: {\n          // To do: use structured clone.\n          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: state.footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     It’s highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     It’s likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype =\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  (\n    function (destination, options) {\n      return destination && 'run' in destination\n        ? bridge(destination, options)\n        : mutate(destination || options)\n    }\n  )\n\nexport default remarkRehype\n\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n  return (node) => toHast(node, options)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n"],"names":["asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","code","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","unicodePunctuation","unicodeWhitespace","regex","test","String","fromCharCode","normalizeUri","value","result","index","start","skip","length","charCodeAt","replace","next","push","slice","encodeURIComponent","join","footnoteReference","state","node","id","identifier","toUpperCase","safeId","toLowerCase","footnoteOrder","indexOf","counter","footnoteCounts","reuseCounter","link","type","tagName","properties","href","clobberPrefix","dataFootnoteRef","ariaDescribedBy","children","patch","sup","applyData","revert","subtype","referenceType","suffix","label","alt","contents","all","head","unshift","tail","listItemLoose","spread","undefined","pointStart","point","pointEnd","position","line","column","offset","handlers","blockquote","wrap","break","lang","match","className","meta","data","delete","emphasis","footnote","footnoteById","no","heading","depth","html","dangerous","imageReference","def","definition","src","url","title","image","inlineCode","text","linkReference","listItem","parent","results","loose","listLoose","checked","paragraph","disabled","child","list","Array","isArray","includes","ordered","root","strong","table","rows","firstRow","shift","tableContent","body","end","tableCell","tableRow","siblings","align","cellIndex","cells","cell","alignValue","trimLines","thematicBreak","toml","ignore","yaml","footnoteDefinition","convert","ok","check","castFactory","typeFactory","tests","checks","any","_len","arguments","parameters","_key","call","this","anyFactory","key","propsFactory","Error","_len2","_key2","Boolean","visitParents","tree","visitor","reverse","is","step","factory","parents","name","Object","defineProperty","visit","subresult","grandparents","toResult","concat","own","hasOwnProperty","definitions","cache","create","clean","from","to","hName","hChildren","hProperties","one","passThrough","unknownHandler","defaultUnknownHandler","values","nodes","toHast","options","settings","allowDangerousHtml","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","footnoteBackLabel","augment","left","right","ctx","props","createState","foot","listItems","content","referenceIndex","backReferences","backReference","dataFootnoteBackref","ariaLabel","tailTail","dataFootnotes","JSON","parse","stringify","footer","destination","file","run","error","bridge","mutate","EXIT"],"sourceRoot":""}